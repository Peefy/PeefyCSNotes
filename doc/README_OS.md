
## 操作系统

*线程和进程的区别*

**进程**: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位

**线程**: 是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程

*一个程序至少一个进程，一个进程至少一个线程*

每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进

* 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改变线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来

* 进程分为单线程进程和多线程进程，单线程进程宏观看起来也是线性执行过程，微观上只有单一的执行过程。多线程进程是宏观是线性的，微观上执行过个操作

线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化

*进程线程的区别*

* 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
* 资源拥有：同一进程的线程共享本进程的资源如内存、I/O、CPU等，但是进程之间的资源是独立的

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

* 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中,由应用程序提供过个线程执行控制
* 线程是处理器调度的基本单位，但是进程不是
* 两者均可并发执行

优缺点：

* 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器(双CPU系统)上运行
* 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移.

*对资源的管理和保护要求高，不限制开销和效率时，使用多进程；要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程*

*Buffer和Cathe的区别*

* **Buffer**-缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情
* **Cache**-Cache：缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而  Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能

**操作系统内存管理**

## LRU - Least Recently Used 最近最少使用

内存管理的一种页面置换算法，对于在内存中但又不用的数据块（内存块）叫做LRU，操作系统会根据哪些数据属于LRU而将其移出内存而腾出空间来加载另外的数据。

关于`操作系统的内存管理`，如何节省利用容量不大的内存为最多的`进程`提供资源，一直是研究的重要方向。而内存的虚拟存储管理，是现在最通用，最成功的方式—— 在内存有限的情况下，**扩展一部分外存作为虚拟内存**，真正的内存只存储当前运行时所用得到信息。

<img src="https://github.com/Peefy/PeefyCSNotes/tree/master/src/LRU.jpg" />

> 可以基于 哈希表HashMap 和 双向链表实现 LRU 

可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点，如图所示。LRU 存储是基于双向链表实现的，其中 head 代表双向链表的表头，tail 代表尾部。首先预先设置 LRU 的容量，如果存储满了，可以通过 O(1) 的时间淘汰掉双向链表的尾部，每次新增和访问数据，都可以通过 O(1)的效率把新的节点增加到对头，或者把已经存在的节点移动到队头。

## Linux

### Linux简介

Linux是一套免费使用核自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统

Linux能运行主要的UNIX工具软件、应用程序和网络协议。支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统

**Linux的发行版本**

Linux的发行版本说简单点就是将Linux内核与应用软件做一个打包

知名的发行版：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS等

**Linux应用领域**

各种场合都适用各种Linux发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器适用LAMP(Linux+Apache+MySQL+PHP)或(Linux+Nginx+MySQL+PHP)组合

### Linux安装

[64位Linux系统CentOS](http://www.runoob.com/linux/linux-install.html)

### Linux系统启动过程

* 内核引导：打开电源，BIOS开机自检，按照设置的启动设备（硬盘）启动，操作系统接管硬件，首先读入/boot目录下的内核文件
* 运行init：init进程是系统所有进程的起点，是所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动，init进程首先读取配置文件/etc/inittab。

许多程序需要开机启动，在windows叫做服务(service)，在linux叫做守护进程(daemon),但是不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做“运行级别”(runlevel),就是说，启动时根据“运行级别”，确定要运行哪些程序。

Linux系统由7个运行级别

* 系统初始化：在init的配置文件中有这么一行：si::sysinit"/etc/rc.d/rc.sysinit 调用了/etc/rc.d/rc.sysinit,而它是bash shell脚本
* 建立终端：rc执行完毕后，返回init。这时基本系统环境已经建立好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统，
* 用户登录系统：命令行登录、ssh登录、图形界面登录

**图形模式与文字模式相互切换**

Linux预设提供了六个命令窗口终端机让我们登录，默认登录窗口tty1，可以按下Ctrl+Alt+F1~F6来切换，如果安装了图形界面，默认情况进入图形界面，Ctrl+Alt+F7可以从文字模式界面回到图形模式界面

**Linux关机**

在Linux领域内大多用在服务器上，很少遇到关机的操作。服务器上跑一个服务是永无止境的，除非特殊情况下

正确关机的流程：sync > shutdown > reboot > halt

关机指令为：shutdown，可以使用man shutdown来看一下帮助文档

sync: 将数据由内存同步到硬盘中

### Linux系统结构目录

在Linux或Unix操作系统中，所有的文件和目录都被组织成以一个根结点开始的倒置的树状结构。文件系统的最顶层是由根目录开始的，系统使用/来表示根目录
* . : 代表当前的目录，也可以使用./来表示
* .. : 代表上一层目录，也可以../来代表

登录系统后，在当前命令窗口下输入命令，可以看到树状目录结构
```shell
ls /
```

* /bin : bin是Binary的缩写，存放着最经常使用的命令
* /boot : 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件
* /dev : dev是Device(设备)的缩写，该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
* /etc : 这个目录用来存放所有的系统管理所需要的配置文件和子目录
* /home : 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的
* /lib : 存放着系统最基本的动态链接共享库，类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库
* /lost+found : 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件
* /media : linux系统会自动识别一些设备，例如一些设备，例如U盘，光驱等等，当识别后，linux会把识别的设备挂到这个目录下
* /mnt : 系统提供该目录是为了让用户临时挂载别的文件系统的，可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容
* /opt : 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下，默认是空的
* /proc : 虚拟的目录，系统内存的映射
* /root : 该目录为系统管理员，也称作超级权限者的用户主目录
* /sbin : s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序
* /selinux : 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的
* /srv : 该目录存放一些服务启动之后需要提取的数据
* /sys : 这是linux2.6内核一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs文件系统集成了下面3中文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统
* /tmp : 存放一些临时文件
* /usr : 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows的program files目录
* /usr/bin : 系统用户使用的应用程序
* /usr/sbin : 超级用几用户使用的比较高级的管理程序和系统守护程序
* /usr/src : 内核源代码默认的放置目录
* /var : 目录存放着不断扩充着的东西，习惯将经常修改的目录放在里面。包括各种日志文件。
* /run : 临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删除或清除。如果系统上有/var/run目录,应该指向run

在Linux系统中，有几个目录是比较重要的，注意不要误删除或者随意更改内部文件。

/etc : 上边也提到了，是系统的配置文件，如果更改了该目录下的某个文件可能会导致系统不能启动

/bin,/sbin,/usr/bin,/usr/sbin : 这是系统预设的执行文件的放置目录，比如ls就是/bin/ls目录下的。值得提出的是，/bin,/usr/bin是给系统用户使用的指令(除root外的通用户),而/sbin,/usr/sbin则是给root使用的指令。

/var : 非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log目录下，另外mail的预设放置也是在这里.

### Linux忘记密码解决方法

忘记密码后，不需要重新安装系统，进入单用户模式更改一下root密码即可。

### Linux远程登录

可以通过远程登录Linux服务器来管理维护系统。Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为22.

windows系统上Linux远程登录客户端SecureCRT,Putty,SSH Secure Shell, 文本以Putty为例来登录远程服务器

**使用密钥认证机制远程登录Linux**

SSH为Secure Shell的缩写，有IETF的网络工作小组(Network Working Group)所制定，SSH为建立在应用层和传输层基础上的安全协议

### Linux文件基本属性

Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限，为了保护系统的安全性，Linux系统对不同的用户访问同一文件(包括目录文件)的权限做了不同的规定

在Linux中可以使用ll或ls -l命令来显示一个文件的属性以及文件所属的用户和组

### Linux查看CPU和内存使用情况

top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。运行 top 命令后，CPU 使用状态会以全屏的方式显示，并且会处在对话的模式 -- 用基于 top 的命令，可以控制显示方式等等。退出 top 的命令为 q （在 top 运行中敲 q 键一次）。

第一行（top）：

　　15:24:36 系统当前时刻

　　14 days 系统启动后到现在的运作时间

　　3 users 当前登录到系统的用户，更确切的说是登录到用户的终端数 -- 同一个用户同一时间对系统多个终端的连接将被视为多个用户连接到系统，这里的用户数也将表现为终端的数目

第二行（Tasks）：

　　288 total 当前系统进程总数

　　1 running 当前运行中的进程数

　　287 sleeping 当前处于等待状态中的进程数

　　0 stoped 被停止的系统进程数

　　0 zombie 僵尸进程数

第三行（Cpus）：

　　7.3% us 用户空间占用CPU百分比
　　2.0% sy 内核空间占用CPU百分比
　　0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比
　　90.4% id 空闲CPU百分比
　　0.3% wa 等待输入输出的CPU时间百分比
　　0.0% hi
　　0.0% si

　　0.0% st

第四行（Mem）：

　　2042616 total 物理内存总量
　　1770116 used 使用的物理内存总量
　　272500 free 空闲内存总量
　　163912 buffers 用作内核缓存的内存量

第五行（Swap）：

表示类别同第四行（Mem），但此处反映着交换分区（Swap）的使用情况。通常，交换分区（Swap）被频繁使用的情况，将被视作物理内存不足而造成的。

　　2094076 total 交换区总量
　　45052 used 使用的交换区总量
　　2049024 free 空闲交换区总量
　　346624 cached 缓冲的交换区总量

以 PID 区分的进程列表将根据所设定的画面更新时间定期的更新。通过 top 内部命令可以控制此处的显示方式:

　　PID：进程的ID
　　USER：进程所有者
　　PR：进程的优先级别，越小越优先被执行
　　NInice：值
　　VIRT：进程占用的虚拟内存
　　RES：进程占用的物理内存
　　SHR：进程使用的共享内存
　　S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
　　%CPU：进程占用CPU的使用率
　　%MEM：进程使用的物理内存和总内存的百分比
　　TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
　　COMMAND：进程启动命令名称

**ps命令**

ps命令用于报告当前系统的进程状态。ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。

**pmap命令**

pmap命令用于报告进程的内存映射关系

**free命令**

free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区

### Linux文件与目录管理

Linux的目录结构为树状结构，最顶级的目录为根目录 / 
其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。

* 绝对路径：由根目录写起，例如：/usr/share/doc
* 相对路径：由 . 和 .. 等构成，例如：cd ../man

**处理目录的常用命令**

* **ls : 列出目录**

选项与参数：`-a` 全部的文件；`-d`仅列出目录本身，不列出所有文件数据；`-l` 场数据串列出，包含文件的属性与权限等等数据 ，例如 
```bash
ls -al
```

* **cd : 切换目录**

cd是Change Directory的缩写，变换工作目录的命令

```bash
cd [相对路径或绝对路径]
```

* **pwd : 显示目前的目录**

选项与参数： `-P`:显示出确实的路径，而非使用连结(link)路径

* **mkdir : 创建一个新的目录**

选项和参数：`-m`: 配置文件权限，*umask*为默认权限; 
`-p`: 直接将所需要的目录(包含上一级目录)递归创建起来，用于创建多层目录

* **rmdir : 删除一个空的目录**

选项和参数：`-p`: 连同上一级*空的*目录也一起删除

* **cp : 复制文件或目录**

选项和参数：
`-a` : 相当于-pdr的意思
`-d` : 若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
`-f` : 为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
`-i` : 若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
`-l` : 进行硬式连结(hard link)的连结档创建，而非复制文件本身；
`-p` : 连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
`-r` : 递归持续复制，用於目录的复制行为；(常用)
`-s` : 复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
`-u` : 若 destination 比 source 旧才升级 destination 

* **rm : 移除文件或目录**

选项和参数：
`-f` : force,忽略不存在的文件，不出现警告信息
`-i` : 互动模式，在删除前会询问使用者是否动作
`-r` : 递归删除，

* **mv : 移动文件与目录，或修改文件与目录的名称**

选项和参数：
`-f` : force,如果目标文件已经存在，不会询问而直接覆盖
`-i` : 若目标文件(destination)已经存在时，就会询问是否覆盖
`-u` : 若目标文件已经存在，且source比较新，才会升级(update)

> *可以使用man命令查看各个命令的使用文档*

**Linux文件内容查看**

* **cat : 由第一行开始显示文件内容**

选项与参数
`-A` : 相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
`-b` : 列出行号，仅针对非空白行做行号显示，空白行不标行号！
`-E` : 将结尾的断行字节 $ 显示出来；
`-n` : 列印出行号，连同空白行也会有行号，与 -b 的选项不同；
`-T` : 将 *tab* 按键以 ^I 显示出来；
`-v` : 列出一些看不出来的特殊字符

* **tac : 从最后一行开始显示，tac是cat的倒置写法**

tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：

* **nl : 显示的时候，一同输出行号**

选项与参数
`-b` : 指定行号指定的方式，主要有两种：
`-b a` : 表示不论是否为空行，也同样列出行号(类似 cat -n)；
`-b t` : 如果有空行，空的那一行不要列出行号(默认值)；

`-n` : 列出行号表示的方法，主要有三种：
`-n ln` : 行号在荧幕的最左方显示；
`-n rn` : 行号在自己栏位的最右方显示，且不加 0 ；
`-n rz` : 行号在自己栏位的最右方显示，且加 0 ；

`-w` : 行号栏位的占用的位数。

* **more : 一页一页地显示文件内容**

`空白键(space)` : 代表向下翻一页；
`Enter` : 代表向下翻『一行』；
`/字串` : 代表在这个显示的内容当中，向下搜寻『字串』这个关键字；
`:f` : 立刻显示出档名以及目前显示的行数；
`q` : 代表立刻离开 more ，不再显示该文件内容。
`b或[ctrl]-b` : 代表往回翻页，不过这动作只对文件有用，对管线无用。

* **less : less与more类似，但是向前翻页**

`空白键(space)` : 向下翻动一页；
`[pagedown]` : 向下翻动一页；
`[pageup]` : 向上翻动一页；
`/字串` : 向下搜寻『字串』的功能；
`?字串` : 向上搜寻『字串』的功能；
`n` : 重复前一个搜寻 (与 / 或 ? 有关！)
`N` : 反向的重复前一个搜寻 (与 / 或 ? 有关！)
`q` : 离开 less 这个程序；

* **head : 只看头几行**

`-n` : 后面接数字，代表显示几行的意思

* **tail : 只看尾几行**

`-n` : 后面接数字，代表显示几行的意思
`-f` : 表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测

### Linux用户和用户组管理

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统

每个用户账号都拥有唯一的用户名和各自的口令，用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录

* 用户账号的添加、删除与修改
* 用户口令的管理
* 用户组的管理

**一、Linux系统用户账号的管理**

涉及用户账号的添加、修改和删除.添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用

**1.添加新的用户账号使用useradd命令，其语法如下：**

```bash
useradd 选项 用户名
```
参数和选项：
`-c comment` : 指定一段注释性描述；
`-d` : 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
`-g` : 用户组 指定用户所属的用户组。
`-G` : 用户组，用户组 指定用户所属的附加组。
`-s` : Shell文件 指定用户的登录Shell。
`-u` : 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

```bash
useradd -d /usr/sam -m sam
```

此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam (/usr为默认的用户主目录所在的父目录)

```bash
useradd -s /bin/sh -g group -G adm, root gem
```

此命令创建了一个用户gem,该用户的登录Shell是/bin/sh,又同时数据adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及group adm
增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow,/etc/group等。

*Linux提供了集成的系统管理工具userconf,可以用来对用户账号进行统一管理*

**2.删除账号**

删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录

```bash
user del 选项 用户名
```

常用选项是`-r`,作用是把用户的主目录一起删除

**3.修改账号**

根据实际情况更改用户的有关属性，如用户号，主目录，用户组，登录Shell等。。

```bash
usermod 选项 用户名
```

参数和选项：
`-c comment` : 指定一段注释性描述；
`-d` : 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
`-g` : 用户组 指定用户所属的用户组。
`-G` : 用户组，用户组 指定用户所属的附加组。
`-s` : Shell文件 指定用户的登录Shell。
`-u` : 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。
`-l` : 新用户名

**4.用户口令的管理**

用户创建时没有口令，但是被系统锁定，无法使用，必须为其制定口令后才可以使用，即使是空口令。

```bash
passwd 选项 用户名
```

参数和选项：
`-l` : 锁定口令，即禁用账号
`-u` : 口令解锁
`-d` : 使账号无口令。
`-f` : 强迫用户下次登录时修改口令。

如果是超级用户，可以使用下列形式指定任何用户的口令
```bash
passwd sam
```

**二、Linux系统用户组的管理**

用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新

**1.增加一个新的用户组**

```bash
groupadd 选项 用户组
```

参数和选项：
`-g` : GID指定新用户组的组标识号(GID)
`-o` : 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同

**2.删除一个已有用户组**

```bash
groupdel 用户组
```

**3.修改用户组的属性使用groupmod命令。其语法如下**

groupmod 选项 用户组

参数和选项：
`-g` : GID指定新用户组的组标识号(GID)
`-o` : 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同
`-n` : 新用户组 将用户组的名字改为新名字

**4.如果一个用户同时属于多个用户组，那么可以在用户组之间切换，以便具有其他用户组的权限**

使用newgrp命令切换到其他用户组

**三、与用户账号有关的系统文件**

这些文件包括/etc/passwd, /etc/shadow, /etc/group

**1./etc/passwd文件是用户管理工作涉及的最重要的一个文件**

对所有用户可读，一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式含义如下：

```bash
用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
```

* "用户名"是代表用户账号的字符串。
* “口令”一些系统中，存放着加密后的用户口令字。
* “用户标识号”是一个整数，系统内部用它来标识用户。
* “组标识号”字段记录的是用户所属的用户组。
* “注释性描述”字段记录着用户的一些个人情况。
* “主目录”，也就是用户的起始工作目录。
* 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。
* 系统中有一类用户称为伪用户（pseudo users）。

**2.拥有账户文件**

1.除了上面列出的伪用户外，还有许多标准的伪用户，例如：**audit，cron，mail，usenet**等，它们也都各自为相关的进程和文件所需要

2./etc/shadow中的记录行与/etc/passwd中的一一对应，由pwconv命令根据/etc/passwd中的数据自动产生

```bash
登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
```

**3.用户组的所有信息都存放在/etc/group文件中**

将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段
每个用户都属于某个用户组：一个组中可以有多个用户，一个用户也可以属于不同的组
用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员.
用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件,由冒号(:)隔开若干个字段，这些字段有：

```bash
组名:口令:组标识号:组内用户列表
```

* "组名"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
* "口令"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
* "组标识号"与用户标识号类似，也是一个整数，被系统内部用来标识组。
* "组内用户列表"是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

**四、批量添加用户**

* 1.先编辑一个文本用户文件:每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID/宿主目录都不可以相同，其中密码栏可以留作空白或输入x号。
* 2.以root身份执行命令、/usr/sbin/newusers,从刚创建的用户文件user.txt中导入数据
* 3.执行命令/usr/sbin/pwunconv。
* 4.编辑每个用户的密码对照文件。
* 5.以root身份执行命令 /usr/sbin/chpasswd
* 6.确定密码经编码写入/etc/passwd的密码栏后。

### Linux磁盘管理

Linux磁盘管理好坏直接关系到整个系统的性能问题
Linux磁盘管理常用三个命令为df、du和fidisk

* **df** : 列出文件系统的整体磁盘使用量

df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取
硬盘被占用了多少空间，目前还剩下多少空间信息

选项和参数：
* -a : 列出所有的文件系统，包括系统特有的/proc等文件系统
* -k : 以 KBytes 的容量显示各文件系统；
* -m : 以 MBytes 的容量显示各文件系统；
* -h : 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；
* -H : 以 M=1000K 取代 M=1024K 的进位方式；
* -T : 显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
* -i : 不用硬盘容量，而以 inode 的数量来显示

注意：*在Linux操作系统下，如果df没有加任何选项,那么默认会将系统内所有的(不含特殊内存的文件系统与swap)都以1Kbytes的容量来列出来*

* **du** : 检查磁盘空间使用量

Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的查看，还是和df命令有一些区别的

选项和参数：
* -a : 列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
* -h : 以人们较易读的容量格式 (G/M) 显示；
* -s : 列出总量而已，而不列出每个各别的目录占用容量；
* -S : 不包括子目录下的总计，与 -s 有点差别。
* -k : 以 KBytes 列出容量显示；
* -m : 以 MBytes 列出容量显示；

通配符*来代表每个目录
与df不一样的是，du这个命令其实会直接到文件系统内去搜寻所有的文件数据

* **fdisk** : 用于磁盘分区

选项和参数：
* -l : 输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。

**磁盘格式化**
磁盘分割完毕后自然是对文件系统的格式化，格式化的命令非常的简单

```bash
mkfs [-t 文件系统格式] 装置文件名
```

选项和参数：
* -t : 可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)

**磁盘检验**
fsck(file system check)用来检查和维护一致的文件系统。若系统掉电或者磁盘发生问题，可利用fsck命令对文件系统进行检查
```bash
fsck [-t 文件系统] [-ACay] 装置名称
```

选项和参数：
* -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数
* -s : 依序一个一个地执行 fsck 的指令来检查
* -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查
* -C : 显示完整的检查进度
* -d : 打印出 e2fsck 的 debug 结果
* -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行
* -R : 同时有 -A 条件时，省略 / 不检查
* -V : 详细显示模式
* -a : 如果检查有错则自动修复
* -r : 如果检查有错则由使用者回答是否修复
* -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。

**磁盘挂载与卸除**
Linux的磁盘挂载使用mount命令，卸载使用umount命令

磁盘挂载语法:
```bash
mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点
```
磁盘卸载命令umount语法:
```bash
umount [-fn] 装置文件名或挂载点
```

选项与参数
* -f : 强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；
* -n : 不升级 /etc/mtab 情况下卸除。

Linux 操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性存放在 inode 中，至于实际数据则放置到 data block 区块中。另外，还有一个超级区块（superblock）会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。

inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block。

在 Linux 中，可以使用 stat 命令查看某个文件的 inode 信息：

### Linux vi/vim

所有的Unix Like系统都会内建vi文书编辑器，其他的不一定存在。目前使用较多是vim编辑器

Vim是从vi发展出来的一个文本编辑器，类似于Sublime，VS Code等

**三种使用模式**:
* 命令模式：

几种常用的几个命令
* i切换到输入模式，以输入字符
* **x**删除当前光标所在处的字符
* :切换到底线命令模式，以在最底一行输入命令

* 输入模式：

输入模式中可以使用的按键
* 字符按键以及Shift组合：输入字符
* ENTER:回车键，换行
* BACK SPACE:退格键，删除光标前一个字符
* DEL:删除键，删除光标后一个字符
* 方向键：在文本中移动光标
* HOME/END:移动光标到行首/行尾
* Page Up/Page Down:上/下翻页
* Insert:切换光标为输入/替换模式，光标将变成竖线/下划线
* ESC:退出输入模式，切换到命令模式

* 底线命令模式：

在命令模式下按下英文冒号就进入了底线命令模式
* q 退出程序
* w 保存文件

### Linux yum命令

yum (Yellow dog Updater, Modified)是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装

yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，简洁好记

语法：
```bash
yum [options] [command] [package ...]
```

* options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为“yes”）,-q（不显示安装的过程）等等。
* command：要进行的操作
* package：操作的对象

常用命令:
* **yum check-update** ：列出所有可更新的软件清单命令
* **yum update** ：更新所有软件命令
* **yum install \<package_name\>** ：仅安装指定的软件命令
* **yum update \<package_name\>** ：仅更新指定的软件命令
* **yum list** ：列出所有可安裝的软件清单命令
* **yum remove \<package_name\>** ：删除软件包命令
* **yum search \<keyword\>** ：查找软件包命令
* **yum clean packages** ：清除缓存目录下的软件包
* **yum clean headers** ：清除缓存目录下的 headers
* **yum clean oldheaders** ：清除缓存目录下旧的 headers
* **yum clean, yum clean all** ：清除缓存目录下的软件包及旧的headers

**国内yum源**

网易(163)yum源是国内最好的yum源之一，无论是速度还是软件版本，都非常不错
将yum源设置为163 yum，可以提升软件包安装和更新速度，同时避免一些常见软件版本无法找到

安装步骤
* 1.首先备份/etc/yum.repos.d/CentOS-Base.repo
```bash
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
```
* 2.下载对应操作系统版本的repo文件，放入/etc/yum.repos.d/ (操作前做好相应备份)
```bash
wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
mv CentOS6-Base-163.repo CentOS-Base.repo
```
* 3.运行以下命令生成缓存
```bash
yum clean all
yum makecache
```

### Linux命令大全

[菜鸟教程链接](http://www.runoob.com/linux/linux-command-manual.html)

## 操作系统问答

**1. Linux虚拟地址空间**

在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间(Virtual Address Space)，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。

虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化

用户进程部分分段存储内容如下表所示(按地址递减顺序)：

名称|存储内容
-|-
栈|局部变量、函数参数、返回地址等
堆|动态分配的内存
BSS段|未初始化或初值为0的全局变量和静态局部变量
数据段|已初始化且初值非0的全局变量和静态局部变量
代码段|可执行代码、字符串字面值、只读变量

**2. 操作系统中的程序的内存结构**

在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。

* **内核空间**-内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。
* **栈(stack)**-栈又称堆栈，由编译器自动分配释放，行为类似数据结构中的栈(先进后出)。
* **内存映射段(mmap)**-此处，内核将硬盘文件的内容直接映射到内存, 任何应用程序都可通过Linux的mmap()系统调用或Windows的CreateFileMapping()/MapViewOfFile()请求这种映射。内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。
* **堆(heap)**-堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用malloc(C)/new(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用free(C)/delete(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。
* **BSS段**-BSS(Block Started by Symbol)段中通常存放程序中以下符号：未初始化的全局变量和静态局部变量；初始值为0的全局变量和静态局部变量(依赖于编译器实现)；未定义且初值不为0的符号(该初值即common block的大小)
* **数据段(Data)**-数据段通常用于存放程序中已初始化且初值不为0的全局变量和静态局部变量。数据段属于静态内存分配(静态存储区)，可读可写。
* **代码段(text)**-代码段也称正文段或文本段，通常用于存放程序执行代码(即CPU执行的机器指令)。一般C语言执行语句都编译成机器代码保存在代码段。通常代码段是可共享的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可。代码段通常属于只读，以防止其他程序意外地修改其指令(对该段的写操作将导致段错误)。某些架构也允许代码段为可写，即允许修改程序。
* **保留区**-位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。

**3. 操作系统中的缺页中断**

在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： 

* 保护CPU现场 
* 分析中断原因 
* 转入缺页中断处理程序进行处理
* 恢复CPU现场，继续执行 

但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别： 

* 在指令执行期间产生和处理缺页中断信号 
* 一条指令在执行期间，可能产生多次缺页中断 
* 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令

**4. fork和vfork的区别**

`fork()`与`vfock()`都是创建一个进程，总结有以下三点区别： 

* fork()：子进程拷贝父进程的数据段，代码段; vfork()：子进程与父进程共享数据段 
* fork()父子进程的执行次序不确定; vfork 保证子进程先运行，在调用exec或exit之前与父进程数据是共享的,在它调用exec或exit 之后父进程才可能被调度运行。
* vfork()保证子进程先运行，在她调用exec 或exit 之后父进程才可能被调度运行。如果在
调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。下面通过几个例子加以说明： 

**5. 如何修改文件最大句柄数？**

Linux中

```bash
ulimit -n 2048
```

这命令就可以修改linux最大文件句柄数，修改以后使用ulimit -a 查看修改的状态，如：

**6. 并发(concurrency)和并行(parallelism)的区别**

concurrency指并行（同时运行），parallelism指并发（同时发生）。

那么两者有什么区别呢，可以说这两个概念完全是两个不同的概念，并发（concurrency）指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。而并行（parallelism）指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。

**7. 操作系统中的页表寻址**

在操作系统中存在一个虚拟内存的概念，它用于内存的管理，使得应用程序认为它有一段连续的内存，大大地简化了程序员码代码的难度。程序员只用关注在这个连续的虚拟内存段中怎么使用内存，不用关心在物理内存中到底用那一段内存，进程运行的时候操作系统会自动进行映射。操作系统是怎么做到的呢？实际上操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，页表的内容就是该进程的虚拟地址到物理地址的一个映射。

数组保存，虚拟空间中的每一个页都分配一个数组项。该数组指向与之关联的页帧, 但这会引发一个问题, 例如, IA-32体系结构使用4KB大小的页,在虚拟地址空间为4GB的前提下,则需要包含1048576 
(4G/4K=1024*1024=1048576)项的页表，要寻址4G的空间，需要32位,也就是4Bytes, 1048576项需要4M(4 * 1024 * 1024 Bytes=4M)的内存.这个问题在64位体系结构下, 情况会更加糟糕. 而每个进程都需要自身的页表,这会导致系统中大量的内存都用来保存页表.

* **Linux的两级分页机制**-两级分页机制将32位的虚拟空间分成三段，对就是三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。 
* **Linux的三级页表**-Intel通过在处理器上把管脚数从32增加到36，以提高处理器的寻址能力，使其达到2^36=64GB，但是linux依然使用32位的虚拟寻址空间，为此，需引入一种新的分页机制。
* **Linux的四级页表**-随着硬件的发展，64位的CPU出现了，这个时候基于32位处理器的三级页表又不能使用了，不过现在的硬件已经可以支持四级页表了，可以使用48位的虚拟空间了

**8. 单核机器上写多线程程序，是否需要考虑加锁，为什么？**

不需要加锁，因为处理器同一个时刻只会有一个线程去访问临界区，不存在冲突的情况。而核心也只支持一个线程执行，因此不存在冲突。如果某个线程持有锁，那只有其他线程不会被调度到CPU上执行，影响的只是持有和释放锁的时间，处理器时刻在运行着。但是在多核上运行时，锁或临界区会导致其余处理器空闲而只允许一个处理器执行持有锁的那个线程，这是一个串行的过程，会影响性能。

**9. 线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的**

线程有创建和上下文切换的开销。线程切换时需要保存堆栈指针SP,程序计数器PC,段SS，页cr3，和ESP，EBP 这些寄存器。

* **堆栈指针SP**-指向栈顶位置。一般堆栈的栈底不能动，所以数据入栈前要先修改堆栈指针，使它指向新的空余空间然后再把数据存进去，出栈的时候相反。
* **程序计数器PC**-用于存放下一条指令所在单元的地址的地方
* **扩展累加器寄存器EAX**-a, 8位累加器。8080。b 基址，c 计数，d数据
ax，16位累加器，由ah，al 组成。x就是h加l，没特别意义，8086。bx=bh+bl,cx=ch+cl,dx=dh+dl
eax，32位累加器，80386
rax，64位累加器。X86-64

**10. 线程间的同步方式，最好说出具体的系统调用**

* **临界区（CCriticalSection）**-当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。
```c
g_CriticalSection.Lock();
g_CriticalSection.Unlock();
```
* **事件（CEvent）**-事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。
```c
CEvent(BOOL bInitiallyOwn=FALSE,
          BOOL bManualReset=FALSE,
          LPCTSTR lpszName=NULL,
          LPSECURITY_ATTRIBUTES lpsaAttribute=NULL);
```
* **互斥量（CMutex）**-互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。
* **信号量（CSemphore）**-当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是当前还可以使用该资源的线程数目。
```c
CSemaphore(
   LONG lInitialCount = 1,
   LONG lMaxCount = 1,
   LPCTSTR pstrName = NULL,
   LPSECURITY_ATTRIBUTES lpsaAttributes = NULL 
);
```

**11. 多线程和多进程的区别和选择**

*区别*

对比维度|多进程|多线程|总结
-|-|-|-
数据共享、同步|数据共享复杂，需要用IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势
内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优
创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优
编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优
可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优
分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优

*选择*

* 需要频繁创建销毁的优先用线程
* 需要进行大量计算的优先使用线程
* 强相关的处理用线程，弱相关的处理用进程
* 可能要扩展到多机分布的用进程，多核分布的用线程
* 都满足需求的情况下，用你最熟悉、最拿手的方式

*对比*

* **消耗资源**-从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
* **通讯方式**-进程之间传递数据只能是通过通讯的方式，即费时又不方便。线程时间数据大部分共享（线程函数内部不共享），快捷方便。但是数据同步需要锁对于static变量尤其注意
* **线程自身优势**-提高应用程序响应；使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的
* **CPU上**-改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

*fock_test.c*

```c
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#define P_NUMBER 255 //并发进程数量
#define COUNT 5 //每次进程打印字符串数
#define TEST_LOGFILE "logFile.log"
FILE *logFile=NULL;
char *s="hello linux\0";
int main()
{
    int i=0,j=0;
    logFile=fopen(TEST_LOGFILE,"a+");//打开日志文件
    for(i=0;i<P_NUMBER;i++)
    {
        if(fork()==0)//创建子进程，if(fork()==0){}这段代码是子进程运行区间
        {
            for(j=0;j<COUNT;j++)
            {
                printf("[%d]%s\n",j,s);//向控制台输出
                /*当你频繁读写文件的时候，Linux内核为了提高读写性能与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。可能导致测试结果不准，所以在此注释*/
                //fprintf(logFile,"[%d]%s\n",j,s);//向日志文件输出，
            }
            exit(0);//子进程结束
        }
    }
    
    for(i=0;i<P_NUMBER;i++)//回收子进程
    {
        wait(0);
    }
    
    printf("Okay\n");
    return 0;
}
```

*thread_test.c*

```c
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#define P_NUMBER 255//并发线程数量
#define COUNT 5 //每线程打印字符串数
#define TEST_LOG "logFile.log"
FILE *logFile=NULL;
char *s="hello linux\0";
print_hello_linux()//线程执行的函数
{
    int i=0;
    for(i=0;i<COUNT;i++)
    {
        printf("[%d]%s\n",i,s);//想控制台输出
        /*当你频繁读写文件的时候，Linux内核为了提高读写性能与速度，会将文件在内存中进行缓存，这部分内存就是Cache Memory(缓存内存)。可能导致测试结果不准，所以在此注释*/
        //fprintf(logFile,"[%d]%s\n",i,s);//向日志文件输出
    }
    pthread_exit(0);//线程结束
}
int main()
{
    int i=0;
    pthread_t pid[P_NUMBER];//线程数组
    logFile=fopen(TEST_LOG,"a+");//打开日志文件
    
    for(i=0;i<P_NUMBER;i++)
        pthread_create(&pid[i],NULL,(void *)print_hello_linux,NULL);//创建线程
        
    for(i=0;i<P_NUMBER;i++)
        pthread_join(pid[i],NULL);//回收线程
        
    printf("Okay\n");
    return 0;
}
```

**12. 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？**

最佳线程数目 =（线程等待时间与线程CPU时间之比 + 1）* CPU数目

用一个进程，使用线程池开辟多个线程进行IO操作

**13. OS缺页置换算法**

* **最佳置换算法OPT**-这是理想算法，不可能实现的。该算法是指，其所选择的淘汰页面，将是以后不再使用，或者未来最长时间内不再被访问的页面。这样来保证最低的缺页率。
* **先进先出置换算法FIFO**-置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
* **最近最久未使用算法LRU**-是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，如果最近一段时间内某些页面被频繁访问，那么在将来还可能被频繁访问。反之，未被访问的将来也不会被访问
* **时钟**-时钟是 LRU 的近似实现。最简单的时钟策略需要给每一页框管理一个附加位，称为使用位。当某一页首次装入内存时，则将该页框的使用位置为 1；当该页随后被访问到时（在访问产生缺页中断后），他的使用位也会被置为 1。对于页面置换算法用于置换的候选页框集合被视为一个循环缓冲区，并且有一个指针与之相关联。当一页被置换时，该指针被设置成指向缓冲区中的下一个页框。当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一个页框。每当遇到一个使用位为 1 的页框时，操作系统就将该为重新置为 0 ；如果在这个过程开始时，缓冲区所有页框的使用位均为 0，则选择遇到的第一个页框置换；如果所有页框的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位都置为 0，并且停留在最初的位置上，置换该页框中的页。

**14. 多进程和多线程的使用场景**

*区别*

* 进程是分配资源的基本单位；线程是系统调度和分派的基本单位
* 属于同一进程的线程，堆是共享的，栈是私有的
* 属于同一进程的所有线程都具有相同的地址空间

*多进程的优点*

* 编程相对容易；通常不需要考虑锁和同步资源的问题
* 更强的容错性：比起多线程的一个好处是一个进程崩溃了不会影响其他进程
* 有内核保证的隔离：数据和错误隔离。 对于使用如C/C++这些语言编写的本地代码，错误隔离是非常有用的：采用多进程架构的程序一般可以做到一定程度的自恢复；（master守护进程监控所有worker进程，发现进程挂掉后将其重启）

*多线程的优点*

* 创建速度快，方便高效的数据共享.共享数据：多线程间可以共享同一虚拟地址空间；多进程间的数据共享就需要用到共享内存、信号量等IPC技术
* 较轻的上下文切换开销 - 不用切换地址空间，不用更改寄存器，不用刷新TLB
* 提供非均质的服务。如果全都是计算任务，但每个任务的耗时不都为1s，而是1ms-1s之间波动；这样，多线程相比多进程的优势就体现出来，它能有效降低“简单任务被复杂任务压住”的概率

*多进程应用场景*

* nginx主流的工作模式是多进程模式（也支持多线程模型） 
* 几乎所有的web server服务器服务都有多进程的，至少有一个守护进程配合一个worker进程，例如apached,httpd等等以d结尾的进程包括init.d本身就是0级总进程，所有你认知的进程都是它的子进程；
* chrome浏览器也是多进程方式。 （原因：①可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。②网页之间互相隔离，保证安全，不必担心某个网页中的恶意代码会取得存放在其他网页中的敏感信息。）
* redis也可以归类到“多进程单线程”模型（平时工作是单个进程，涉及到耗时操作如持久化或aof重写时会用到多个进程）

*多线程应用场景*

* 线程间有数据共享，并且数据是需要修改的（不同任务间需要大量共享数据或频繁通信时）
* 提供非均质的服务（有优先级任务处理）事件响应有优先级
* 单任务并行计算，在非CPU Bound的场景下提高响应速度，降低时延
* 与人有IO交互的应用，良好的用户体验（键盘鼠标的输入，立刻响应）

*对比*

* **消耗资源**-从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。
* **通讯方式**-进程之间传递数据只能是通过通讯的方式，即费时又不方便。线程时间数据大部分共享（线程函数内部不共享），快捷方便。但是数据同步需要锁对于static变量尤其注意
* **线程自身优势**-提高应用程序响应；使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的
* **CPU上**-改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

**15. 死锁发生的条件以及如何解决死锁**

*产生死锁的四个必要条件*

* **互斥条件**-进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待
* **不可剥夺条件**-进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)
* **请求与保持条件**-进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
* **循环等待条件**-存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有

*解决死锁的方法*

* **有序资源分配法**-这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：
* **银行家算法**-
* **避免死锁**-加锁顺序、加锁时限、死锁检测
* **检测死锁**-由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：能发现死锁并从死锁状态中恢复出来。因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。
* **解除死锁的方法**-
1. 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 
2. 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
3. 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

**16. 虚拟内存和物理内存怎么对应**

操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的

进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

* 每次访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
* 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
* 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过**页表**来记录
* 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
* 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
* 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

**17. 操作系统中的结构体对齐，字节对齐**

*对齐规则*：结构体的对齐规则是先按数据类型自身进行对齐，然后再按整个结构体进行对齐，对齐值必须是2的幂，比如1，2， 4， 8， 16。如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。比如int按四字节对齐，那么int类型的变量起始地址一定是4的倍数，比如 0x0012ff60，0x0012ff48等。

**18. 进程间怎么通信**

* **管道Pipe**-管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端;只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）;可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

```c
#include<stdio.h>
#include<unistd.h>

int main()
{
    int fd[2];  // 两个文件描述符
    pid_t pid;
    char buff[20];

    if(pipe(fd) < 0)  // 创建管道
        printf("Create Pipe Error!\n");

    if((pid = fork()) < 0)  // 创建子进程
        printf("Fork Error!\n");
    else if(pid > 0)  // 父进程
    {
        close(fd[0]); // 关闭读端
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]); // 关闭写端
        read(fd[0], buff, 20);
        printf("%s", buff);
    }

    return 0;
}
```

* **FIFO**-FIFO，也称为命名管道，它是一种文件类型。FIFO可以在无关的进程之间交换数据，与无名管道不同。IFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

write_fifo.c
```c
#include<stdio.h>
#include<stdlib.h>   // exit
#include<fcntl.h>    // O_WRONLY
#include<sys/stat.h>
#include<time.h>     // time

int main()
{
    int fd;
    int n, i;
    char buf[1024];
    time_t tp;

    printf("I am %d process.\n", getpid()); // 说明进程ID
    
    if((fd = open("fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO 
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    for(i=0; i<10; ++i)
    {
        time(&tp);  // 取系统当前时间
        n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
        printf("Send message: %s", buf); // 打印
        if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
        {
            perror("Write FIFO Failed");
            close(fd);
            exit(1);
        }
        sleep(1);  // 休眠1秒
    }

    close(fd);  // 关闭FIFO文件
    return 0;
}
```

read_fifo.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<fcntl.h>
#include<sys/stat.h>

int main()
{
    int fd;
    int len;
    char buf[1024];

    if(mkfifo("fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
        perror("Create FIFO Failed");

    if((fd = open("fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
    {
        perror("Open FIFO Failed");
        exit(1);
    }
    
    while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
        printf("Read message: %s", buf);

    close(fd);  // 关闭FIFO文件
    return 0;
}
```

* **消息队列**-消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

msg_server.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;
    
    // 获取key值
    if((key = ftok(MSG_FILE,'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Server key is: %d.\n", key);

    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 循环读取消息
    for(;;) 
    {
        msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
        printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
        printf("Server: receive msg.mtype is: %d.\n", msg.mtype);

        msg.mtype = 999; // 客户端接收的消息类型
        sprintf(msg.mtext, "hello, I'm server %d", getpid());
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}
```

msg_client.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;

    // 获取key值
    if ((key = ftok(MSG_FILE, 'z')) < 0) 
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Client key is: %d.\n", key);

    // 打开消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1) 
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 添加消息，类型为888
    msg.mtype = 888;
    sprintf(msg.mtext, "hello, I'm client %d", getpid());
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    // 读取类型为777的消息
    msgrcv(msqid, &msg, 256, 999, 0);
    printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
    printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
    return 0;
}
```

* **信号量**-信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。

```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/sem.h>

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
    union semun tmp;
    tmp.val = value;
    if(semctl(sem_id, 0, SETVAL, tmp) == -1)
    {
        perror("Init Semaphore Error");
        return -1;
    }
    return 0;
}

// P操作:
//    若信号量值为1，获取资源并将信号量值-1 
//    若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//    释放资源并将信号量值+1
//    如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
    union semun tmp;
    if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
    {
        perror("Delete Semaphore Error");
        return -1;
    }
    return 0;
}


int main()
{
    int sem_id;  // 信号量集ID
    key_t key;  
    pid_t pid;

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 创建信号量集，其中只有一个信号量
    if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
    {
        perror("semget error");
        exit(1);
    }

    // 初始化：初值设为0资源被占用
    init_sem(sem_id, 0);

    if((pid = fork()) == -1)
        perror("Fork Error");
    else if(pid == 0) /*子进程*/ 
    {
        sleep(2);
        printf("Process child: pid=%d\n", getpid());
        sem_v(sem_id);  /*释放资源*/
    }
    else  /*父进程*/
    {
        sem_p(sem_id);   /*等待资源*/
        printf("Process father: pid=%d\n", getpid());
        sem_v(sem_id);   /*释放资源*/
        del_sem(sem_id); /*删除信号量集*/
    }
    return 0;
}
```

* **共享内存**-共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

server.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>  // shared memory
#include<sys/sem.h>  // semaphore
#include<sys/msg.h>  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
    union semun tmp;
    tmp.val = value;
    if(semctl(sem_id, 0, SETVAL, tmp) == -1)
    {
        perror("Init Semaphore Error");
        return -1;
    }
    return 0;
}

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
    union semun tmp;
    if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
    {
        perror("Delete Semaphore Error");
        return -1;
    }
    return 0;
}

// 创建一个信号量集
int creat_sem(key_t key)
{
    int sem_id;
    if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
    {
        perror("semget error");
        exit(-1);
    }
    init_sem(sem_id, 1);  /*初值设为1资源未占用*/
    return sem_id;
}


int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    char data[] = "this is server";
    struct shmid_ds buf1;  /*用于删除共享内存*/
    struct msqid_ds buf2;  /*用于删除消息队列*/
    struct msg_form msg;  /*消息队列用于通知对方更新了共享内存*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 创建共享内存
    if((shmid = shmget(key, 1024, IPC_CREAT|0666)) == -1)
    {
        perror("Create Shared Memory Error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }


    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 创建信号量
    semid = creat_sem(key);
    
    // 读数据
    while(1)
    {
        msgrcv(msqid, &msg, 1, 888, 0); /*读取类型为888的消息*/
        if(msg.mtext == 'q')  /*quit - 跳出循环*/ 
            break;
        if(msg.mtext == 'r')  /*read - 读共享内存*/
        {
            sem_p(semid);
            printf("%s\n",shm);
            sem_v(semid);
        }
    }

    // 断开连接
    shmdt(shm);

    /*删除共享内存、消息队列、信号量*/
    shmctl(shmid, IPC_RMID, &buf1);
    msgctl(msqid, IPC_RMID, &buf2);
    del_sem(semid);
    return 0;
}
```

client.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>  // shared memory
#include<sys/sem.h>  // semaphore
#include<sys/msg.h>  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}


int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    struct msg_form msg;
    int flag = 1; /*while循环条件*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 获取共享内存
    if((shmid = shmget(key, 1024, 0)) == -1)
    {
        perror("shmget error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }

    // 创建消息队列
    if ((msqid = msgget(key, 0)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 获取信号量
    if((semid = semget(key, 0, 0)) == -1)
    {
        perror("semget error");
        exit(1);
    }
    
    // 写数据
    printf("***************************************\n");
    printf("*                 IPC                 *\n");
    printf("*    Input r to send data to server.  *\n");
    printf("*    Input q to quit.                 *\n");
    printf("***************************************\n");
    
    while(flag)
    {
        char c;
        printf("Please input command: ");
        scanf("%c", &c);
        switch(c)
        {
            case 'r':
                printf("Data to send: ");
                sem_p(semid);  /*访问资源*/
                scanf("%s", shm);
                sem_v(semid);  /*释放资源*/
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
                msg.mtype = 888;  
                msg.mtext = 'r';  /*发送消息通知服务器读数据*/
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                break;
            case 'q':
                msg.mtype = 888;
                msg.mtext = 'q';
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                flag = 0;
                break;
            default:
                printf("Wrong input!\n");
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
        }
    }

    // 断开连接
    shmdt(shm);

    return 0;
}
```

五种通信方式总结：
* **管道**-速度慢，容量有限，只有父子进程能通讯
* **FIFO**-任何进程间都能通讯，但速度慢    
* **消息队列**-容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   
* **信号量**-不能传递复杂消息，只能用来同步    
* **共享内存区**-能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

**19. 虚拟内存置换的方式**

* **最佳置换算法OPT**-这是理想算法，不可能实现的。该算法是指，其所选择的淘汰页面，将是以后不再使用，或者未来最长时间内不再被访问的页面。这样来保证最低的缺页率。
* **先进先出置换算法FIFO**-置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
* **最近最久未使用算法LRU**-是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，如果最近一段时间内某些页面被频繁访问，那么在将来还可能被频繁访问。反之，未被访问的将来也不会被访问
* **时钟**-时钟是 LRU 的近似实现。最简单的时钟策略需要给每一页框管理一个附加位，称为使用位。当某一页首次装入内存时，则将该页框的使用位置为 1；当该页随后被访问到时（在访问产生缺页中断后），他的使用位也会被置为 1。对于页面置换算法用于置换的候选页框集合被视为一个循环缓冲区，并且有一个指针与之相关联。当一页被置换时，该指针被设置成指向缓冲区中的下一个页框。当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一个页框。每当遇到一个使用位为 1 的页框时，操作系统就将该为重新置为 0 ；如果在这个过程开始时，缓冲区所有页框的使用位均为 0，则选择遇到的第一个页框置换；如果所有页框的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位都置为 0，并且停留在最初的位置上，置换该页框中的页。

**20. 多线程，线程同步的几种方式**

* **事件Event**-用事件（Event）来同步线程是最具弹性的了。一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。事件又分两种类型：手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。所以用自动重置事件来同步两个线程比较理想。MFC中对应的类为CEvent。CEvent的构造函数默认创建一个自动重置的事件，而且处于未激发状态。共有三个函数来改变事件的状态:SetEvent,ResetEvent和PulseEvent。用事件来同步线程是一种比较理想的做法，但在实际的使用过程中要注意的是，对自动重置事件调用SetEvent和PulseEvent有可能会引起死锁，必须小心。
* **临界区Critical Section**-使用临界区域的第一个忠告就是不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。但进入临界区后必须尽快地离开，释放资源。如果不释放的话，会如何？答案是不会怎样。如果是主线程（GUI线程）要进入一个没有被释放的临界区，呵呵，程序就会挂了！临界区域的一个缺点就是：Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死，如果进入临界区的线程挂了，没有释放临界资源，系统无法获知，而且没有办法释放该临界资源。这个缺点在互斥器(Mutex)中得到了弥补。Critical Section在MFC中的相应实现类是CcriticalSection。CcriticalSection：：Lock()进入临界区，CcriticalSection：：UnLock()离开临界区。
* **互斥器Mutex**-互斥器的功能和临界区域很相似。区别是：Mutex所花费的时间比Critical Section多的多，但是Mutex是核心对象(Event、Semaphore也是)，可以跨进程使用，而且等待一个被锁住的Mutex可以设定TIMEOUT，不会像Critical Section那样无法得知临界区域的情况，而一直死等。MFC中的对应类为CMutex。Win32函数有：创建互斥体CreateMutex() ，打开互斥体OpenMutex()，释放互斥体ReleaseMutex()。Mutex的拥有权并非属于那个产生它的线程，而是最后那个对此Mutex进行等待操作（WaitForSingleObject等等）并且尚未进行ReleaseMutex()操作的线程。线程拥有Mutex就好像进入Critical Section一样，一次只能有一个线程拥有该Mutex。如果一个拥有Mutex的线程在返回之前没有调用ReleaseMutex()，那么这个Mutex就被舍弃了，但是当其他线程等待(WaitForSingleObject等)这个Mutex时，仍能返回，并得到一个WAIT_ABANDONED_0返回值。能够知道一个Mutex被舍弃是Mutex特有的。
* **信号量Semaphore**-信号量是最具历史的同步机制。信号量是解决producer/consumer问题的关键要素。对应的MFC类是Csemaphore。Win32函数CreateSemaphore（）用来产生信号量。ReleaseSemaphore（）用来解除锁定。Semaphore的现值代表的意义是可用的资源数，如果Semaphore的现值为1，表示还有一个锁定动作可以成功。如果现值为5，就表示还有五个锁定动作可以成功。当调用Wait…等函数要求锁定，如果Semaphore现值不为0，Wait…马上返回，资源数减1。当调用ReleaseSemaphore（）资源数加1，当然不会超过初始设定的资源总数。

**21. 互斥锁（mutex）机制，以及互斥锁和读写锁的区别**

相交进程之间的关系主要有两种，同步与互斥。所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。所谓同步，是指散布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务

* 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
* 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

*互斥锁和同步锁的不同*

* 读写锁：多个读者可以同时进行读,写者必须互斥（只允许一个写者写，也不能读者写者同时进行）,写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
```c
pthread_rwlock_init()
pthread_rwlock_rdlock()
pthread_rwlock_wrlock()
pthread_rwlock_unlock()
```
* 互斥锁:一次只能一个线程拥有互斥锁，其他线程只有等待
```c
pthread_mutex_init()
pthread_mutex_lock()
pthread_mutex_unlock()
```

**22. 进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞**

* **就绪状态**-一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。
* **执行状态**-当一个进程在处理机上运行时，则称该进程处于运行状态。
* **阻塞状态**-一个进程正在等待某一事件发生（例如请求I／O而等待I／O完成等）而暂时仃止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。
* **挂起状态**-由于IO的速度慢于CPU的运算速度，经常出现CPU等待I/O的情况。这时OS需要将主存中的进程对换至外存。在进程行为模式中需要增加一个新的挂起（suspend）状态。当内存中所有进程阻塞时，OS可将一进程置为挂起态并交换到外存，再调入另一个进程执行。
* **新建状态**-进程刚创建，但还不能运行，OS还没有把它加到可执行进程组中，通常是还没有加载到主存中的新进程。
* **退出状态**-OS从可执行进程组中释放出的进程，或者是因为它自身停止了，或者是因为某种原因被取消。进程不在适合执行，但与作业相关的表和其它信息临时被OS保留起来，为其他程序提供所需信息。
* **活跃就绪**-指进程在主存并旦可被调度的状态。
* **静止就绪**-指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。
* **活跃阻塞**-指进程在主存中。一旦等待的事件产生，便进入活跃就绪状态。
* **静止阻塞**-指进程对换到辅存时的阻塞状态。一旦等待的事件产生，便进入静止就绪状态。

**23. A* a = new A; a->i = 10;在内核中的内存分配上发生了什么？**

创建一个**堆**中对象并用**栈**上的指针变量a指向它，然后写入**堆**中存储对象字段i的值

注意：malloc是在**自由存储区**分配对象的，new是从**堆**中创建

**24. 一个类，里面有static，virtual，之类的，来说一说这个类的内存分布**

static修饰成员变量、成员函数

因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在没有产生类对象前就可以使用。Static修饰的成员函数，在代码区分配内存。

虚函数表

基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。查找该虚函数表中该函数的指针进行调用。C++内部为每一个类维持一个虚函数表，该类的对象的都指向这同一个虚函数表。

如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new/malloc动态申请的，则该类数据存储在堆区。

如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储

**25. 软链接和硬链接区别**

* **原理上**-

硬链接(hard link)：A是B的硬链接（A和B都是文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。

软链接(soft link)：A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。

* **使用限制上**-

硬链接：a.不能对目录创建硬链接，原因有几种，最重要的是：文件系统不能存在链接环（目录创建时的".."除外，这个系统可以识别出来）,存在环的后果会导致例如文件遍历等操作的混乱(du，pwd等命令的运作原理就是基于文件硬链接，顺便一提，ls -l结果的第二列也是文件的硬链接数，即inode节点的链接数)。不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下。不能对不存在的文件创建硬链接，由原理即可知原因。

软链接：a.可以对目录创建软链接，遍历操作会忽略目录的软链接。可以跨文件系统。可以对不存在的文件创建软链接，因为放的只是一个字符串，至于这个字符串是不是对于一个实际的文件，就是另外一回事了。

* **命令**-

硬链接：ln 源文件 链接名

软链接：ln -s 源文件 链接名

**26. 什么是大端小端以及如何判断大端小端**

大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。

小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。

```c
static union { char c[4]; unsigned long l; }endian_test = { { 'l', '?', '?', 'b' } };
#define ENDIANNESS ((char)endian_test.l)
```
(如果ENDIANNESS=’l’表示系统为little endian,为’b’表示big endian )。

目前Intel的80x86系列芯片是唯一还在坚持使用小端的芯片，ARM芯片默认采用小端，但可以切换为大端；而MIPS等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。另外，对于大小端的处理也和编译器的实现有关，在C语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如Keil 51C），Java是平台无关的，默认是大端。在网络上传输数据普遍采用的都是大端。

**27. 静态变量什么时候初始化**

静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。

**28. 用户态和内核态区别**

内核态与用户态是操作系统的两种运行级别,当程序运行在3级特权级上时，
就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运
行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程
序运行在0级特权级上时，就可以称之为运行在内核态。运行在用户态下
的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行
一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完
成某些它没有权力和能力完成的工作时就会切换到内核态。 

三种情况导致用户态到内核态的切换

* 系统调用
* 异常
* 外围设备的中断

**29. 如何设计server，使得能够接收多个客户端的请求**

从接收得到的socket中读取客户ip地址信息，以此ip为依据判断之前该客户端是否已建立了与服务器的连接，如果之前还未建立，那么就在服务器端重开一个线程，并将此socket传入，线程中拿到这个socket之后在其内部进行相应的处理，该线程随后会被存入一个Map中，其以ip地址为键，线程对象为值；

下次如果此客户端再发来请求，就可以在此Map中直接找到处理它的线程来对其进行处理；

线程中在需要等待客户端信息才能继续的地方，暂时用wait来令其等待，当主线程又接到此客户端的一个请求信息之后，再将该线程唤醒（Notify）；

当客户端断开连接时（服务器端会收到一个标记量），服务器端的线程运行结束，并将Map中的对应项移除。

**30. 死循环+来连接时新建线程的方法效率有点低，怎么改进？**

线程池改善创建线程的开销，

**31. 唤醒被阻塞的socket线程？**

shutdown函数，关闭socket读写的通道

**32. 怎样确定当前线程是繁忙还是阻塞？**

是否放弃CPU的使用权

**33. 空闲的进程和阻塞的进程状态会不会在唤醒的时候误判？**

不会

**34. 堆和栈的区别**

* **管理方式**-栈由编译器自动管理；堆由程序员控制，使用方便，但易产生内存泄露
* **生长方向**-栈向低地址扩展(即”向下生长”)，是连续的内存区域；堆向高地址扩展(即”向上生长”)，是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历。
* **空间大小**-栈顶地址和栈的最大容量由系统预先规定(通常默认2M或10M)；堆的大小则受限于计算机系统中有效的虚拟内存，32位Linux系统中堆内存可达2.9G空间。
* **存储内容**-栈在函数调用时，首先压入主调函数中下条指令(函数调用语句的下条可执行语句)的地址，然后是函数实参，然后是被调函数的局部变量。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句。堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。
* **分配方式**-栈可静态分配或动态分配。静态分配由编译器完成，如局部变量的分配。动态分配由alloca函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。
* **分配效率**-栈由计算机底层提供支持：分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行，因此效率较高。堆由函数库提供，机制复杂，效率比栈低得多。Windows系统中VirtualAlloc可直接在进程地址空间中分配一块内存，快速且灵活。
* **分配后系统响应**-只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示栈溢出。操作系统为堆维护一个记录空闲内存地址的链表。当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序。若无足够大小的空间(可能由于内存碎片太多)，有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回。，大多数系统会在该内存空间首地址处记录本次分配的内存大小，供后续的释放函数(如free/delete)正确释放本内存空间。此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将多余的部分重新放入空闲链表中。
* **碎片问题**-栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出。而频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。可见，堆容易造成内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和内核态切换，内存申请的代价更为昂贵。所以栈在程序中应用最广泛，函数调用也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放。所以，建议尽量使用栈，仅在分配大量或大块内存空间时使用堆。使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果。

**35. fopen在windows和linux下的用法区别**

* 形式：

windows:
```c
FILE *fp = fopen("D:\quick_sort.c", "r");
```
linux:
```c
FILE *fp = fopen("/home/quick_sort.c", "r");
```
* 参数区别：
UNIX/Linux 不分文本文件和二进制文件，而Windows下时区分的。考虑程序平台兼容性，若以二进制形式打开，最好加'b'

windows，一般以二进制打开，最好加上b,例如rb

linux，直接r即可，不需要额外指明文本还是二进制文件

**36. CentOS 和 Linux的关系？**

操作系统主要分3个部分，分别是：内核、库、应用程序

内核主要管理与硬件的直接交互的原语代码就类似dao层的一个方法，是原子性的，而库是对内核的进一步封装，当一个功能需要多个原语时，就比如有的程序，需要键盘的输入，还需要显示器的显示，就可以调用库中的封装好的方法；应用程序是系统级的应用程序，直接调用库中的方法。

centos厂家就自己写库和应用程序部分，衍生出各种版本，除此之外还有 redhat等。CentOS是Community ENTerprise Operating System的简称，我们有很多人叫它社区企业操作系统，不管你怎么叫它，它都是Linux操作系统的一个发行版本。

**37. 操作系统64位和32位的区别？**

64bit计算主要有两大好处：可以进行更大范围的整数运算；可以支持更大的内存。

* **设计初衷不同**-64位操作系统的设计初衷是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。而32位操作系统是为普通用户设计的。
* **要求配置不同**-64位操作系统只能安装在64位电脑上（CPU必须是64位的）。同时需要安装64位常用软件以发挥64位（x64）的最佳性能。32位操作系统则可以安装在32位（32位CPU）或64位（64位CPU）电脑上。当然，32位操作系统安装在64位电脑上，其硬件恰似“大牛拉小车”：64位效能就会大打折扣。
* **运算速度不同**-64位CPUGPRs的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可提取64位数据(只要两个指令，一次提取8个字节的数据)，比32位（需要四个指令，一次提取4个字节的数据）提高了一倍，理论上性能会相应提升1倍。
* **寻址能力不同**-64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。
* **软件普及不同**-64位常用软件比32位常用软件，要少得多的多。道理很简单：使用64位操作系统的用户相对较少。因此，软件开发商必须考虑“投入产出比”，将有限资金投入到更多使用群体的软件之中。这也是为什么64位软件价格相对昂贵的重要原因（将成本摊入较少的发售之中）。

64位操作系统可以安装32位软件，设计上的“向下兼容”。

**38. 怎么杀死进程？**

首先，用ps查看进程
```linux
$ ps -ef
$ ps -aux
```

若想杀死进程，就使用如下指令
```linux
$ kill -s 9 [进程PID]
```
其中-s 9 制定了传递给进程的信号是9，即强制、尽快终止进程

查看进程PID的改进：

* 把ps的查询结果通过管道给grep查找包含特定字符串的进程。管道符“|”用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。
```linux
$ ps -ef | grep firefox
```
* 使用pgrep：
```linux
$ pgrep firefox
```
* 使用pidof：
```linux
$ pidof firefox-bin
```
* “grep firefox”的输出结果是，所有含有关键字“firefox”的进程。“grep -v grep”是在列出的进程中去除含有关键字“grep”的进程。“cut -c 9-15”是截取输入行的第9个字符到第15个字符，而这正好是进程号PID。“xargs kill -s 9”中的xargs命令是用来把前面命令的输出结果（PID）作为“kill -s 9”命令的参数，并执行该命令。“kill -s 9”会强行杀掉指定进程。
```linux
$ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs kill -s 9
```
* 
```linux
$ pgrep firefox | xargs kill -s 9
```
* 
```linux
$ ps -ef | grep firefox | awk '{print $2}' | xargs kill -9
```
* 
```linux
$kill -s 9 `ps -aux | grep firefox | awk '{print $2}'`
```
* pkill
```linux
$kill -s 9 `pgrep firefox`
```
* killall：killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。
```linux
$pkill -9 firefox
```
* 
```linux
```
 
**39. 线程，进程区别**

* **进程**-是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
* **线程**-是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

一个程序至少一个进程，一个进程至少一个线程

* **地址空间**：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
* **资源拥有**：同一进程的线程共享本进程的资源如内存、I/O、CPU等，但是进程之间的资源是独立的

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

* **执行过程**：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中,由应用程序提供过个线程执行控制
* 线程是处理器调度的基本单位，但是进程不是
* 两者均可并发执行

优缺点：

* 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器(双CPU系统)上运行
* 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移.

*对资源的管理和保护要求高，不限制开销和效率时，使用多进程；要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程*

**40. 系统线程数量上限是多少？**

* 总结系统限制有：
/proc/sys/kernel/threads-max #查系统支持的最大线程数，一般会很大，相当于理论值

linux系统
```linux
cat /proc/sys/kernel/threads-max 
4132217
```

* Java虚拟机本身的限制
-Xms  #intial java heap size

-Xmx  #maximum java heap size

-Xss  #the stack size for each thread

* 查询当前某程序的线程或进程数
```linux
pstree -p `ps -e | grep java | awk '{print $1}'` | wc -l
```
上面用的是命令替换，关于命令替换，就是说用``括起来的命令会优先执行，然后以其输出作为其他命令的参数
```linux
pstree -p 进程号 | wc -l
top -H 进程号 | wc -l
```

* 查询当前整个系统已用的线程或进程数
```linux
pstree -p | wc -l
```

**41. 进程和线程的区别是什么？**

* **进程**-是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。
* **线程**-是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

一个程序至少一个进程，一个进程至少一个线程

* **地址空间**：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
* **资源拥有**：同一进程的线程共享本进程的资源如内存、I/O、CPU等，但是进程之间的资源是独立的

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

* **执行过程**：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中,由应用程序提供过个线程执行控制
* 线程是处理器调度的基本单位，但是进程不是
* 两者均可并发执行

优缺点：

* 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器(双CPU系统)上运行
* 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移.

*对资源的管理和保护要求高，不限制开销和效率时，使用多进程；要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程*


**42. 解释一下LINUX下线程，GDI类。**

LINUX实现的就是基于核心轻量级进程的"一对一"线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 

GDI类为图像设备编程接口类库。

**43. socket编程，BIO，NIO，epoll？**

网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

BIO是同步阻塞IO，NIO是同步非阻塞IO，AIO是异步非阻塞IO；三种IO方式相比较而言，BIO是一个客户端对应一个线程，优化的话可以用线程池进行线程复用，但本质还是一个客户端-服务端通信对应一个线程；NIO只需要一个线程负责多路复用器selector的轮询，就可以处理不同客户端channel中的读/写事件，所以多个客户端实际只对应一个线程，另外服务器端和客户端均使用缓冲区的方式进行读写；AIO不需要过多的多路服务器selector即可实现异步读写，可以理解为简化版的NIO；

**44. 什么是页式存储？**

页式存储管理的基本思想是把作业的虚拟地址空间划分成若干长度相等的页(pagE,也称虚页，每一个作业的虚页都从0开始编号。主存也划分成若干与虚页长度相等的页架,framE,也称页框或实页，主存的页架也从0开始编号。程序装入时，每一个虚页装到主存中的一个页架中，这些页架可以是不连续的)

**45. 操作系统里的内存碎片你怎么理解，有什么解决办法？**

内存碎片通常分为内部碎片和外部碎片：

* 内部碎片是由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部碎片，通常内部碎片难以完全避免；

* 外部碎片是由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域。现在普遍采取的内存分配方式是段页式内存分配。将内存分为不同的段，再将每一段分成固定大小的页。通过页表机制，使段内的页可以不必连续处于同一内存区域。

**46. 什么情况下会发生死锁，解决策略有哪些？**

死锁发生的四个必要条件是： 
* 1.资源互斥使用。 
* 2.多个进程保持一定的资源，但又请求新的资源。 
* 3.资源不可被剥夺。 
* 4.多个进程循环等待。 

一般死锁的应对策略有： 
* 1.死锁预防。如进程需要的所有资源，在一开始就全部申请好得到之后再开始执行。 
* 2.死锁避免。如进程每次申请申请资源的时候，根据一定的算法，去看该请求可能不可能造成死锁，如果可能，就不给它分配该资源。 
* 3.死锁处理。破坏四个必要条件的其中一个，比如kill掉一个进程。 
* 4.死锁忽略。不管死锁，由用户自行处理，比如重启电脑。一般的系统其实都采取这种策略。

**47. 系统CPU比较高是什么原因？**

CPU占用使用率其实就是你运行的程序占用的CPU资源，表示你的机器在某个时间点的运行程序的情况。使用率越高，说明你的机器在这个时间上运行了很多程序，反之较少。使用率的高低与你的CPU强弱有直接关系。现代分时多任务操作系统对 CPU 都是分时间片使用的：比如A进程占用10ms，然后B进程占用30ms，然后空闲60ms，再又是A进程占10ms，B进程占30ms，空闲60ms;如果在一段时间内都是如此，那么这段时间内的占用率为40%。CPU对线程的响应并不是连续的，通常会在一段时间后自动中断线程。未响应的线程增加，就会不断加大CPU的占用。cpu使用率高的原因有很多，但是一般都是由于病毒木马或开机启动项过多所致。高CPU使用率也可能表明应用程序的调整或设计不良。优化应用程序可以降低CPU的使用率。

**48. 系统如何提高并发性？**

* **物理层**-增加网络宽带，域名解析分发多台服务器
* **操作系统层**-多线程多核编程，epoll,事件驱动框架，异步消息机制
* **业务层**-优化数据库查询redis缓存

**49. 进程与线程的概念，进程与线程的区别，进程和线程各自同步的方式**

*进程*-进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。

*线程*-线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。

*进程和线程的区别*

一个程序至少一个进程，一个进程至少一个线程

* **地址空间**：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
* **资源拥有**：同一进程的线程共享本进程的资源如内存、I/O、CPU等，但是进程之间的资源是独立的

* 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。
* 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。
* 处理机分给线程，即真正在处理机上运行的是线程。
* 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

*进程/线程间同步的方式*

* **临界区**-通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。
* **互斥量**-采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享 .互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。
* **信号量**-它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目 .信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
* **事件**-通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。

进程间通信主要包括管道, 系统IPC(包括消息队列,信号量,共享存储), SOCKET.

*进程/线程同步机制与进程间通信机制比较*

* 同步主要是临界区、互斥、信号量、事件
* 进程间通信是管道、内存共享、消息队列、信号量、socket
* 共通之处是，信号量和消息（事件）

*进程间通讯(IPC)方法主要有以下几种：*
* **管道**-管道中还有命名管道和非命名管道(即匿名管道)之分，非命名管道(即匿名管道)只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是先进先出的通讯方式
* **消息队列**-消息队列是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据
* **信号量**-与WINDOWS下的信号量是一样的，所以就不用多说了  
* **共享内存**-类似于WINDOWS下的DLL中的共享变量，但LINUX下的共享内存区不需要像DLL这样的东西，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写    

**50. Linux虚拟地址空间**

在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间(Virtual Address Space)，在32位模式下它是一个4GB的内存地址块。在Linux系统中, 内核进程和用户进程所占的虚拟内存比例是1:3，而Windows系统为2:2(通过设置Large-Address-Aware Executables标志也可为1:3)。这并不意味着内核使用那么多物理内存，仅表示它可支配这部分地址空间，根据需要将其映射到物理内存。
用户进程部分分段存储内容如下表所示(按地址递减顺序)：

虚拟地址通过页表(Page Table)映射到物理内存，页表由操作系统维护并被处理器引用。内核空间在页表中拥有较高特权级，因此用户态程序试图访问这些页时会导致一个页错误(page fault)。在Linux中，内核空间是持续存在的，并且在所有进程中都映射到同样的物理内存。内核代码和数据总是可寻址，随时准备处理中断和系统调用。与此相反，用户模式地址空间的映射随进程切换的发生而不断变化。

名称|存储内容
-|-
栈|局部变量、函数参数、返回地址等
堆|动态分配的内存
BSS段|未初始化或初值为0的全局变量和静态局部变量
数据段|已初始化且初值为0的全局变量和静态局部变量
代码段|可执行代码、字符串字面值、只读变量

BSS段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。

**51. 操作系统中的程序的内存结构**

*内存抽象*-在现代的操作系统中，同一时间运行多个进程是再正常不过的了。为了解决直接操作内存带来的各种问题，引入的地址空间(Address Space),这允许每个进程拥有自己的地址。这还需要硬件上存在两个寄存器，基址寄存器(base register)和界址寄存器(limit register),第一个寄存器保存进程的开始地址，第二个寄存器保存上界，防止内存溢出。

任何操作虚拟地址的操作都会被转换为操作物理地址。而每一个进程所拥有的内存地址是完全不同的，因此也使得多进程成为可能。

*虚拟内存*-虚拟内存的基本思想是，每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为页(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)，还有一些没加载在内存中的对应在硬盘上

*页面替换算法*-因为在计算机系统中，读取少量数据硬盘通常需要几毫秒，而内存中仅仅需要几纳秒。一条CPU指令也通常是几纳秒，如果在执行CPU指令时，产生几次缺页中断，那性能可想而知，因此尽量减少从硬盘的读取无疑是大大的提升了性能。而前面知道，物理内存是极其有限的，当虚拟内存所求的页不在物理内存中时，将需要将物理内存中的页替换出去，选择哪些页替换出去就显得尤为重要，如果算法不好将未来需要使用的页替换出去，则以后使用时还需要替换进来，这无疑是降低效率的，让我们来看几种页面替换算法。

**52. 操作系统中的缺页中断**

**53. fork和vfork的区别**

**54. 如何修改文件最大句柄数？**

**55. 并发(concurrency)和并行(parallelism)**

**56. MySQL的端口号是多少，如何修改这个端口号**

* 登录mysql 
```sql
mysql -uroot -p
mysql> show global variables like 'port'
```

修改端口，编辑/etc/my.cnf文件，早期版本有可能是my.conf文件名，增加端口参数，并且设定端口，注意该端口未被使用，保存退出。

**57. 操作系统中的页表寻址**

在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。

缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
* 保护CPU现场 
* 分析中断原因
* 转入缺页中断处理程序进行处理
* 恢复CPU现场，继续执行 

但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：
* 在指令执行期间产生和处理缺页中断信号 
* 一条指令在执行期间，可能产生多次缺页中断
* 缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令

**58. 有了进程，为什么还要有线程？**

`进程`属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。

`线程`是在进程这个层次上提供的一层并发的抽象

* 能够使系统在同一时间能够做多件事情
* 当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
* 可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高

进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：

* 进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了
* 进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。

**59. 单核机器上写多线程程序，是否需要考虑加锁，为什么？**

视情况而定。

如果一个线程是CPU-intensive,另一个是IO-intensive或者是用户交互，那么多线程显然具有优势。

如果都是CPU-intensive的线程，那么意义不大。当然，有的时候我们仍然会在单核机器上创建多线程，其目的通常是占用更多的系统资源以变相提高程序的性能（比如有更大机会被OS调度）。 必须指出的是，引入线程会增加一些开销，所以上述的在单核机器上创建多线程变相提高性能的方法通常较难在性能和额外开销上取得平衡。 

**60. 线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的**

线程有创建和上下文切换的开销。线程切换时需要保存堆栈指针SP,程序计数器PC,段SS，页cr3，和ESP，EBP 这些寄存器。

* **堆栈指针SP**-指向栈顶位置。一般堆栈的栈底不能动，所以数据入栈前要先修改堆栈指针，使它指向新的空余空间然后再把数据存进去，出栈的时候相反。
* **程序计数器PC**-用于存放下一条指令所在单元的地址的地方
* **扩展累加器寄存器EAX**-a, 8位累加器。8080。b 基址，c 计数，d数据
ax，16位累加器，由ah，al 组成。x就是h加l，没特别意义，8086。bx=bh+bl,cx=ch+cl,dx=dh+dl
eax，32位累加器，80386
rax，64位累加器。X86-64

**61. 线程间的同步方式，最好说出具体的系统调用**

* **互斥量（mutex）**-

```c++
#include <pthread.h>
int pthread_mutex_destroy(pthread_mutex_t *mutex); //销毁
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
const pthread_mutexattr_t *restrict attr); //初始化
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_lock(pthread_mutex_t *mutex); //上锁
int pthread_mutex_trylock(pthread_mutex_t *mutex); //尝试上锁
int pthread_mutex_unlock(pthread_mutex_t *mutex); //解锁
```

* **条件变量（Condition Variable）**-

```c++
#include <pthread.h>
int pthread_cond_destroy(pthread_cond_t *cond); //销毁
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr); //初始化
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

int pthread_cond_timedwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex,
const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

* **信号量（Semaphore）**-

```c++
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_post(sem_t * sem);
int sem_destroy(sem_t * sem);
```

*调用sem_wait()可以获得资源，使semaphore的值减1，如果调用sem_wait()时semaphore的值已经是0，则挂起等待。如果不希望挂起等待，可以调用sem_trywait()。调用sem_post()可以释放资源，使semaphore的值加1，同时唤醒挂起等待的线程。*

**62. 多线程和多进程的不同**

对比维度|多进程|多线程|总结
-|-|-|-
数据共享同步|数据共享复杂，需要用IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势
内存、CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|线程占优
创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优
编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优
可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优
分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优

*多线程和多进程的选择*

* **需要频繁创建销毁的优先用线程**-

这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的

* **需要进行大量计算的优先使用线程**-

所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。
这种原则最常见的是图像处理、算法处理。

* **强相关的处理用线程，弱相关的处理用进程**-

什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。

一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。

* **可能要扩展到多机分布的用进程，多核分布的用线程**-

原因同上

* **都满足需求的情况下，用你最熟悉、最拿手的方式**-

至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。 

**63. 进程和线程的区别**

* **地址空间**-同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。
* **资源拥有**-同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

* **执行过程**-每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
* **线程是处理器调度的基本单位，但是进程不是。**-
* **两者均可并发执行**-

**64. 游戏服务器应该为每个用户开辟一个线程还是一个进程，为什么？**

最佳线程数目 =（线程等待时间与线程CPU时间之比 + 1）* CPU数目

用一个进程，使用线程池开辟多个线程进行IO操作

**65. OS缺页置换算法**

* **最佳置换算法(Optimal Page Replacement Algorithm)**-

最佳置换算法是将未来最久不使用的页替换出去，这听起来很简单，但是无法实现。但是这种算法可以作为衡量其它算法的基准。

* **最近不常使用算法(Not Recently Used Replacement Algorithm)**-

这种算法给每个页一个标志位，R表示最近被访问过，M表示被修改过。定期对R进行清零。这个算法的思路是首先淘汰那些未被访问过R=0的页，其次是被访问过R=1,未被修改过M=0的页，最后是R=1,M=1的页。

* **先进先出页面置换算法(First-In,First-Out Page Replacement Algorithm)**-

这种算法的思想是淘汰在内存中最久的页，这种算法的性能接近于随机淘汰。并不好。

* **改进型FIFO算法(Second Chance Page Replacement Algorithm)**-

这种算法是在FIFO的基础上，为了避免置换出经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0.而那些R=0的页将被淘汰时，直接淘汰。这种算法避免了经常被使用的页被淘汰。

* **时钟替换算法(Clock Page Replacement Algorithm)**-

虽然改进型FIFO算法避免置换出常用的页，但由于需要经常移动页，效率并不高。因此在改进型FIFO算法的基础上，将队列首位相连形成一个环路，当缺页中断产生时，从当前位置开始找R=0的页，而所经过的R=1的页被置0，并不需要移动页。

* **最久未使用算法(LRU Page Replacement Algorithm)**-

LRU算法的思路是淘汰最近最长未使用的页。这种算法性能比较好，但实现起来比较困难

**66. 死锁发生的条件以及如何解决死锁**

*产生死锁的四个必要条件*

* **互斥条件**-进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待
* **不可剥夺条件**-进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)
* **请求与保持条件**-进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
* **循环等待条件**-存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有

*解决死锁的方法*

* **有序资源分配法**-这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：
* **银行家算法**-
* **避免死锁**-加锁顺序、加锁时限、死锁检测
* **检测死锁**-由于操作系统有并发，共享以及随机性等特点，通过预防和避免的手段达到排除死锁的目的是很困难的。这需要较大的系统开销，而且不能充分利用资源。一种简便的方法是系统为进程分配资源时，不采取任何限制性措施，但是提供了检测和解脱死锁的手段：能发现死锁并从死锁状态中恢复出来。因此，在实际的操作系统中往往采用死锁的检测与恢复方法来排除死锁。
* **解除死锁的方法**-
1. 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。 
2. 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。
3. 进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

**67. 虚拟内存和物理内存怎么对应**

操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的

进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。

* 每次访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
* 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
* 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过**页表**来记录
* 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
* 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
* 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

**68. 操作系统中的结构体对齐，字节对齐**

*对齐规则*：结构体的对齐规则是先按数据类型自身进行对齐，然后再按整个结构体进行对齐，对齐值必须是2的幂，比如1，2， 4， 8， 16。如果一个类型按n字节对齐，那么该类型的变量起始地址必须是n的倍数。比如int按四字节对齐，那么int类型的变量起始地址一定是4的倍数，比如 0x0012ff60，0x0012ff48等。

**69. 进程间怎么通信**

* **管道Pipe**-管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端;只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）;可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

```c
#include<stdio.h>
#include<unistd.h>

int main()
{
    int fd[2];  // 两个文件描述符
    pid_t pid;
    char buff[20];

    if(pipe(fd) < 0)  // 创建管道
        printf("Create Pipe Error!\n");

    if((pid = fork()) < 0)  // 创建子进程
        printf("Fork Error!\n");
    else if(pid > 0)  // 父进程
    {
        close(fd[0]); // 关闭读端
        write(fd[1], "hello world\n", 12);
    }
    else
    {
        close(fd[1]); // 关闭写端
        read(fd[0], buff, 20);
        printf("%s", buff);
    }

    return 0;
}
```

* **FIFO**-FIFO，也称为命名管道，它是一种文件类型。FIFO可以在无关的进程之间交换数据，与无名管道不同。IFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

write_fifo.c
```c
#include<stdio.h>
#include<stdlib.h>   // exit
#include<fcntl.h>    // O_WRONLY
#include<sys/stat.h>
#include<time.h>     // time

int main()
{
    int fd;
    int n, i;
    char buf[1024];
    time_t tp;

    printf("I am %d process.\n", getpid()); // 说明进程ID
    
    if((fd = open("fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO 
    {
        perror("Open FIFO Failed");
        exit(1);
    }

    for(i=0; i<10; ++i)
    {
        time(&tp);  // 取系统当前时间
        n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
        printf("Send message: %s", buf); // 打印
        if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
        {
            perror("Write FIFO Failed");
            close(fd);
            exit(1);
        }
        sleep(1);  // 休眠1秒
    }

    close(fd);  // 关闭FIFO文件
    return 0;
}
```

read_fifo.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<errno.h>
#include<fcntl.h>
#include<sys/stat.h>

int main()
{
    int fd;
    int len;
    char buf[1024];

    if(mkfifo("fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
        perror("Create FIFO Failed");

    if((fd = open("fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
    {
        perror("Open FIFO Failed");
        exit(1);
    }
    
    while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
        printf("Read message: %s", buf);

    close(fd);  // 关闭FIFO文件
    return 0;
}
```

* **消息队列**-消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。

msg_server.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;
    
    // 获取key值
    if((key = ftok(MSG_FILE,'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Server key is: %d.\n", key);

    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 循环读取消息
    for(;;) 
    {
        msgrcv(msqid, &msg, 256, 888, 0);// 返回类型为888的第一个消息
        printf("Server: receive msg.mtext is: %s.\n", msg.mtext);
        printf("Server: receive msg.mtype is: %d.\n", msg.mtype);

        msg.mtype = 999; // 客户端接收的消息类型
        sprintf(msg.mtext, "hello, I'm server %d", getpid());
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
    }
    return 0;
}
```

msg_client.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/msg.h>

// 用于创建一个唯一的key
#define MSG_FILE "/etc/passwd"

// 消息结构
struct msg_form {
    long mtype;
    char mtext[256];
};

int main()
{
    int msqid;
    key_t key;
    struct msg_form msg;

    // 获取key值
    if ((key = ftok(MSG_FILE, 'z')) < 0) 
    {
        perror("ftok error");
        exit(1);
    }

    // 打印key值
    printf("Message Queue - Client key is: %d.\n", key);

    // 打开消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1) 
    {
        perror("msgget error");
        exit(1);
    }

    // 打印消息队列ID及进程ID
    printf("My msqid is: %d.\n", msqid);
    printf("My pid is: %d.\n", getpid());

    // 添加消息，类型为888
    msg.mtype = 888;
    sprintf(msg.mtext, "hello, I'm client %d", getpid());
    msgsnd(msqid, &msg, sizeof(msg.mtext), 0);

    // 读取类型为777的消息
    msgrcv(msqid, &msg, 256, 999, 0);
    printf("Client: receive msg.mtext is: %s.\n", msg.mtext);
    printf("Client: receive msg.mtype is: %d.\n", msg.mtype);
    return 0;
}
```

* **信号量**-信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。支持信号量组。

```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/sem.h>

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
    union semun tmp;
    tmp.val = value;
    if(semctl(sem_id, 0, SETVAL, tmp) == -1)
    {
        perror("Init Semaphore Error");
        return -1;
    }
    return 0;
}

// P操作:
//    若信号量值为1，获取资源并将信号量值-1 
//    若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//    释放资源并将信号量值+1
//    如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
    union semun tmp;
    if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
    {
        perror("Delete Semaphore Error");
        return -1;
    }
    return 0;
}


int main()
{
    int sem_id;  // 信号量集ID
    key_t key;  
    pid_t pid;

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 创建信号量集，其中只有一个信号量
    if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
    {
        perror("semget error");
        exit(1);
    }

    // 初始化：初值设为0资源被占用
    init_sem(sem_id, 0);

    if((pid = fork()) == -1)
        perror("Fork Error");
    else if(pid == 0) /*子进程*/ 
    {
        sleep(2);
        printf("Process child: pid=%d\n", getpid());
        sem_v(sem_id);  /*释放资源*/
    }
    else  /*父进程*/
    {
        sem_p(sem_id);   /*等待资源*/
        printf("Process father: pid=%d\n", getpid());
        sem_v(sem_id);   /*释放资源*/
        del_sem(sem_id); /*删除信号量集*/
    }
    return 0;
}
```

* **共享内存**-共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

server.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>  // shared memory
#include<sys/sem.h>  // semaphore
#include<sys/msg.h>  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// 初始化信号量
int init_sem(int sem_id, int value)
{
    union semun tmp;
    tmp.val = value;
    if(semctl(sem_id, 0, SETVAL, tmp) == -1)
    {
        perror("Init Semaphore Error");
        return -1;
    }
    return 0;
}

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}

// 删除信号量集
int del_sem(int sem_id)
{
    union semun tmp;
    if(semctl(sem_id, 0, IPC_RMID, tmp) == -1)
    {
        perror("Delete Semaphore Error");
        return -1;
    }
    return 0;
}

// 创建一个信号量集
int creat_sem(key_t key)
{
    int sem_id;
    if((sem_id = semget(key, 1, IPC_CREAT|0666)) == -1)
    {
        perror("semget error");
        exit(-1);
    }
    init_sem(sem_id, 1);  /*初值设为1资源未占用*/
    return sem_id;
}


int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    char data[] = "this is server";
    struct shmid_ds buf1;  /*用于删除共享内存*/
    struct msqid_ds buf2;  /*用于删除消息队列*/
    struct msg_form msg;  /*消息队列用于通知对方更新了共享内存*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 创建共享内存
    if((shmid = shmget(key, 1024, IPC_CREAT|0666)) == -1)
    {
        perror("Create Shared Memory Error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }


    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT|0777)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 创建信号量
    semid = creat_sem(key);
    
    // 读数据
    while(1)
    {
        msgrcv(msqid, &msg, 1, 888, 0); /*读取类型为888的消息*/
        if(msg.mtext == 'q')  /*quit - 跳出循环*/ 
            break;
        if(msg.mtext == 'r')  /*read - 读共享内存*/
        {
            sem_p(semid);
            printf("%s\n",shm);
            sem_v(semid);
        }
    }

    // 断开连接
    shmdt(shm);

    /*删除共享内存、消息队列、信号量*/
    shmctl(shmid, IPC_RMID, &buf1);
    msgctl(msqid, IPC_RMID, &buf2);
    del_sem(semid);
    return 0;
}
```

client.c
```c
#include<stdio.h>
#include<stdlib.h>
#include<sys/shm.h>  // shared memory
#include<sys/sem.h>  // semaphore
#include<sys/msg.h>  // message queue
#include<string.h>   // memcpy

// 消息队列结构
struct msg_form {
    long mtype;
    char mtext;
};

// 联合体，用于semctl初始化
union semun
{
    int              val; /*for SETVAL*/
    struct semid_ds *buf;
    unsigned short  *array;
};

// P操作:
//  若信号量值为1，获取资源并将信号量值-1 
//  若信号量值为0，进程挂起等待
int sem_p(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = -1; /*P操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("P operation Error");
        return -1;
    }
    return 0;
}

// V操作：
//  释放资源并将信号量值+1
//  如果有进程正在挂起等待，则唤醒它们
int sem_v(int sem_id)
{
    struct sembuf sbuf;
    sbuf.sem_num = 0; /*序号*/
    sbuf.sem_op = 1;  /*V操作*/
    sbuf.sem_flg = SEM_UNDO;

    if(semop(sem_id, &sbuf, 1) == -1)
    {
        perror("V operation Error");
        return -1;
    }
    return 0;
}


int main()
{
    key_t key;
    int shmid, semid, msqid;
    char *shm;
    struct msg_form msg;
    int flag = 1; /*while循环条件*/

    // 获取key值
    if((key = ftok(".", 'z')) < 0)
    {
        perror("ftok error");
        exit(1);
    }

    // 获取共享内存
    if((shmid = shmget(key, 1024, 0)) == -1)
    {
        perror("shmget error");
        exit(1);
    }

    // 连接共享内存
    shm = (char*)shmat(shmid, 0, 0);
    if((int)shm == -1)
    {
        perror("Attach Shared Memory Error");
        exit(1);
    }

    // 创建消息队列
    if ((msqid = msgget(key, 0)) == -1)
    {
        perror("msgget error");
        exit(1);
    }

    // 获取信号量
    if((semid = semget(key, 0, 0)) == -1)
    {
        perror("semget error");
        exit(1);
    }
    
    // 写数据
    printf("***************************************\n");
    printf("*                 IPC                 *\n");
    printf("*    Input r to send data to server.  *\n");
    printf("*    Input q to quit.                 *\n");
    printf("***************************************\n");
    
    while(flag)
    {
        char c;
        printf("Please input command: ");
        scanf("%c", &c);
        switch(c)
        {
            case 'r':
                printf("Data to send: ");
                sem_p(semid);  /*访问资源*/
                scanf("%s", shm);
                sem_v(semid);  /*释放资源*/
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
                msg.mtype = 888;  
                msg.mtext = 'r';  /*发送消息通知服务器读数据*/
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                break;
            case 'q':
                msg.mtype = 888;
                msg.mtext = 'q';
                msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
                flag = 0;
                break;
            default:
                printf("Wrong input!\n");
                /*清空标准输入缓冲区*/
                while((c=getchar())!='\n' && c!=EOF);
        }
    }

    // 断开连接
    shmdt(shm);

    return 0;
}
```

五种通信方式总结：
* **管道**-速度慢，容量有限，只有父子进程能通讯
* **FIFO**-任何进程间都能通讯，但速度慢    
* **消息队列**-容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题   
* **信号量**-不能传递复杂消息，只能用来同步    
* **共享内存区**-能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

**70. 虚拟内存置换的方式**

* **最佳置换算法OPT**-这是理想算法，不可能实现的。该算法是指，其所选择的淘汰页面，将是以后不再使用，或者未来最长时间内不再被访问的页面。这样来保证最低的缺页率。
* **先进先出置换算法FIFO**-置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
* **最近最久未使用算法LRU**-是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，如果最近一段时间内某些页面被频繁访问，那么在将来还可能被频繁访问。反之，未被访问的将来也不会被访问
* **时钟**-时钟是 LRU 的近似实现。最简单的时钟策略需要给每一页框管理一个附加位，称为使用位。当某一页首次装入内存时，则将该页框的使用位置为 1；当该页随后被访问到时（在访问产生缺页中断后），他的使用位也会被置为 1。对于页面置换算法用于置换的候选页框集合被视为一个循环缓冲区，并且有一个指针与之相关联。当一页被置换时，该指针被设置成指向缓冲区中的下一个页框。当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一个页框。每当遇到一个使用位为 1 的页框时，操作系统就将该为重新置为 0 ；如果在这个过程开始时，缓冲区所有页框的使用位均为 0，则选择遇到的第一个页框置换；如果所有页框的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位都置为 0，并且停留在最初的位置上，置换该页框中的页。

**71. 多线程，线程同步的几种方式**

* **事件Event**-用事件（Event）来同步线程是最具弹性的了。一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。事件又分两种类型：手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。所以用自动重置事件来同步两个线程比较理想。MFC中对应的类为CEvent。CEvent的构造函数默认创建一个自动重置的事件，而且处于未激发状态。共有三个函数来改变事件的状态:SetEvent,ResetEvent和PulseEvent。用事件来同步线程是一种比较理想的做法，但在实际的使用过程中要注意的是，对自动重置事件调用SetEvent和PulseEvent有可能会引起死锁，必须小心。
* **临界区Critical Section**-使用临界区域的第一个忠告就是不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。但进入临界区后必须尽快地离开，释放资源。如果不释放的话，会如何？答案是不会怎样。如果是主线程（GUI线程）要进入一个没有被释放的临界区，呵呵，程序就会挂了！临界区域的一个缺点就是：Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死，如果进入临界区的线程挂了，没有释放临界资源，系统无法获知，而且没有办法释放该临界资源。这个缺点在互斥器(Mutex)中得到了弥补。Critical Section在MFC中的相应实现类是CcriticalSection。CcriticalSection：：Lock()进入临界区，CcriticalSection：：UnLock()离开临界区。
* **互斥器Mutex**-互斥器的功能和临界区域很相似。区别是：Mutex所花费的时间比Critical Section多的多，但是Mutex是核心对象(Event、Semaphore也是)，可以跨进程使用，而且等待一个被锁住的Mutex可以设定TIMEOUT，不会像Critical Section那样无法得知临界区域的情况，而一直死等。MFC中的对应类为CMutex。Win32函数有：创建互斥体CreateMutex() ，打开互斥体OpenMutex()，释放互斥体ReleaseMutex()。Mutex的拥有权并非属于那个产生它的线程，而是最后那个对此Mutex进行等待操作（WaitForSingleObject等等）并且尚未进行ReleaseMutex()操作的线程。线程拥有Mutex就好像进入Critical Section一样，一次只能有一个线程拥有该Mutex。如果一个拥有Mutex的线程在返回之前没有调用ReleaseMutex()，那么这个Mutex就被舍弃了，但是当其他线程等待(WaitForSingleObject等)这个Mutex时，仍能返回，并得到一个WAIT_ABANDONED_0返回值。能够知道一个Mutex被舍弃是Mutex特有的。
* **信号量Semaphore**-信号量是最具历史的同步机制。信号量是解决producer/consumer问题的关键要素。对应的MFC类是Csemaphore。Win32函数CreateSemaphore（）用来产生信号量。ReleaseSemaphore（）用来解除锁定。Semaphore的现值代表的意义是可用的资源数，如果Semaphore的现值为1，表示还有一个锁定动作可以成功。如果现值为5，就表示还有五个锁定动作可以成功。当调用Wait…等函数要求锁定，如果Semaphore现值不为0，Wait…马上返回，资源数减1。当调用ReleaseSemaphore（）资源数加1，当然不会超过初始设定的资源总数。

**73. windows消息机制**

消息，就是指Windows发出的一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序。

消息本身是作为一个记录传递给应用程序的，这个记录（一般在 C/C++/汇编 中称为“结构体”）中包含了消息的类型以及其他信息。例如，对单击鼠标所产生的消息来说，这个记录（结构体）中包含了单击鼠标的消息号（WM_LBUTTONDOWN）、单击鼠标时的坐标(由X,Y值连接而成的一个32位整数)。这个记录类型叫做TMsg。

Windows消息控制中心一般是三层结构，其顶端就是Windows内核。Windows内核维护着一个消息队列，第二级控制中心从这个消息队列中获取属于自己管辖的消息，后做出处理，有些消息直接处理掉，有些还要发送给下一级窗体(Window)或控件（Control）。第二级控制中心一般是各Windows应用程序的Application对象。第三级控制中心就是Windows窗体对象，每一个窗体都有一个默认的窗体过程，这个过程负责处理各种接收到的消息。

**74. C++的锁**

C++11提供了4个互斥对象(C++14提供了1个)用于同步多个线程对共享资源的访问。

类名|描述
-|-
std::mutex|最简单的互斥对象。
std::timed_mutex|带有超时机制的互斥对象，允许等待一段时间或直到某个时间点仍未能获得互斥对象的所有权时放弃等待。
std::recursive_mutex|允许被同一个线程递归的Lock和Unlock。
std::recursive_timed_mutex|顾名思义(bù jiě shì)。
std::shared_timed_mutex(C++14)|允许多个线程共享所有权的互斥对象，如读写锁，本文不讨论这种互斥。

锁是动词而非名词，互斥对象的主要操作有两个加锁(lock)和释放锁(unlock)。当一个线程对互斥对象进行lock操作并成功获得这个互斥对象的所有权，在此线程对此对象unlock前，其他线程对这个互斥对象的lock操作都会被阻塞。

*使用RAII管理互斥对象*

在使用锁时应避免发生死锁(Deadlock)。如果程序有多个分支，不得不在每个要提前返回的分支在返回前对这个互斥对象执行unlock操作。一但有某个分支在返回前忘了对这个互斥对象执行unlock，就可能会导致程序死锁。为避免这类死锁的发生，其他高级语言如C#提供了lock关键字、Java提供了synchronized关键字，它们都是通过finally关键字来实现的。

C++通常使用RAII(Resource Acquisition Is Initialization)来自动管理资源。如果可能应总是使用标准库提供的互斥对象管理类模板。

类模板|描述
-|-
std::lock_guard|	严格基于作用域(scope-based)的锁管理类模板，构造时是否加锁是可选的(不加锁时假定当前线程已经获得锁的所有权)，析构时自动释放锁，所有权不可转移，对象生存期内不允许手动加锁和释放锁。
std::unique_lock|	更加灵活的锁管理类模板，构造时是否加锁是可选的，在对象析构时如果持有锁会自动释放锁，所有权可以转移。对象生命期内允许手动加锁和释放锁。
std::shared_lock(C++14)|	用于管理可转移和共享所有权的互斥对象。

使用std::lock_guard类模板修改前面的代码，在lck对象构造时加锁，析构时自动释放锁，即使执行的函数抛出了异常也会被正确的析构，所以也就不会发生互斥对象没有释放锁而导致死锁的问题。

```c++
std::set<int> int_set;
std::mutex mt;
auto f = [&int_set, &mt]() {
    try {
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1, 1000);
        for(std::size_t i = 0; i != 100000; ++i) {
            std::lock_guard<std::mutex> lck(mt);
            int_set.insert(dis(gen));
        }
    } catch(...) {}
};
std::thread td1(f), td2(f);
td1.join();
td2.join();
```

*互斥对象管理类模板的加锁策略*

C++11提供了3种加锁策略

策略|tag type|描述
-|-|-
(默认)|无|请求锁，阻塞当前线程直到成功获得锁。
std::defer_lock|std::defer_lock_t|不请求锁。
std::try_to_lock|std::try_to_lock_t|尝试请求锁，但不阻塞线程，锁不可用时也会立即返回。
std::adopt_lock|std::adopt_lock_t|假定当前线程已经获得互斥对象的所有权，所以不再请求锁。

下表列出了互斥对象管理类模板对各策略的支持情况。

策略|std::lock_guard|std::unique_lock|std::shared_lock
-|-|-|-
(默认)|√|√|√(共享)
std::defer_lock|×|√|√
std::try_to_lock|×|√|√
std::adopt_lock|√|√|√

**75. 死锁产生的必要条件？**

*产生死锁的四个必要条件*

* **互斥条件**-进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待
* **不可剥夺条件**-进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)
* **请求与保持条件**-进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放
* **循环等待条件**-存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有

**76. 什么是线程和进程，多线程和多进程通信方式**

*线程和进程的区别*

**进程**: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位

**线程**: 是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程

*一个程序至少一个进程，一个进程至少一个线程*

每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进

* 线程的执行过程是线性的，尽管中间会发生中断或者暂停，但是进程所拥有的资源只为改变线状执行过程服务，一旦发生线程切换，这些资源需要被保护起来

* 进程分为单线程进程和多线程进程，单线程进程宏观看起来也是线性执行过程，微观上只有单一的执行过程。多线程进程是宏观是线性的，微观上执行过个操作

线程的改变只代表CPU的执行过程的改变，而没有发生进程所拥有的资源的变化

*进程线程的区别*

* 地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间
* 资源拥有：同一进程的线程共享本进程的资源如内存、I/O、CPU等，但是进程之间的资源是独立的

一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮

进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程

* 执行过程：每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中,由应用程序提供过个线程执行控制
* 线程是处理器调度的基本单位，但是进程不是
* 两者均可并发执行

优缺点：

* 线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器(双CPU系统)上运行
* 进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移.

*多进程之间通信方式*

* **文件映射**-本地之间
* **共享内存**-本地之间
* **匿名管道**-本地之间
* **命名管道**-跨服务器
* **邮件槽**-一对多的传输数据，通常通过网络向一台Windows机器传输
* **剪切板**-本地之间
* **socket**-跨服务器

*多线程之间通信方式*

* **全局变量**-
* **自定义消息响应**-

*多线程之间同步机制*

* **临界区**-不可以跨进程，忘记解锁会无限等待，要么存在要么没有，多线程访问独占性共享资源
* **互斥量**-可以跨进程，忘记解锁会自动释放，要么存在要么没有
* **事件**-又叫线程触发器，不可以跨进程，要么存在要么没有，一个线程来唤醒另一个线程（包括自动和人工两种方式）
* **信号量**-可以跨进程，始终代表可用资源数量，当资源数为o时，线程阻塞，允许多个线程同时访问一个共享资源

**77. 内存溢出和内存泄漏**

`内存溢出 out of memory`-是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

`内存泄露 memory leak`-是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

`内存泄露`会最终导致`内存泄露`

`内存泄漏`是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 

*内存泄露的分类*

* **常发性内存泄漏**-发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
* **偶发性内存泄漏**-发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。
* **一次性内存泄漏**-发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
* **隐式内存泄漏**-程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。

**78. 线程模型**

线程模型|描述
-|-
BIO|阻塞式IO，采用传统的java IO进行操作，该模式下每个请求都会创建一个线程，适用于并发量小的场景
NIO|同步非阻塞，比传统BIO能更好的支持大并发，tomcat 8.0 后默认采用该模式
APR|tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装APR库
AIO|异步非阻塞，tomcat8.0后支持

**79. 协程**

协程不是进程，也不是线程，它就是一个函数，一个特殊的函数——可以在某个地方挂起，并且可以重新在挂起处继续运行。

一个进程可以包含多个线程，一个线程也可以包含多个协程，也就是说，一个线程内可以有多个那样的特殊函数在运行。但是有一点，必须明确，一个线程内的多个协程的运行是串行的。如果有多核CPU的话，多个进程或一个进程内的多个线程是可以并行运行的，但是一个线程内的多个协程却绝对串行的，无论有多少个CPU（核）。

*协程与进程、线程的比较*

* 协程既不是进程，也不是线程，协程仅仅是一个特殊的函数，协程跟他们就不是一个维度。
* 一个进程可以包含多个线程，一个线程可以包含多个协程。
* 一个线程内的多个协程虽然可以切换，但是这多个协程是串行执行的，只能在这一个线程内运行，没法利用CPU多核能力。
* 协程与进程一样，它们的切换都存在上下文切换问题。

*进程、线程、协程的上下文切换的比较*

比较内容|进程|线程|协程
-|-|-|-
切换者|操作系统|操作系统|用户(编程者/应用程序)
切换时机|根据操作系统自己切换策略，用户不感知|根据操作系统自己的切换策略，用户不感知|用户自己(的程序)决定
切换内容|页全局目录,内核栈,硬件上下文|内核栈,硬件上下文|硬件上下文
切换内容的保存|保存于内核栈中|保存于内核栈中|保存于用户自己的变量(用户栈或堆)
切换过程|用户态-内核态-用户态|用户态-内核态-用户态|用户态(没有陷入内核态)
切换效率|低|中|高

**80. 系统调用是什么，为什么要用系统调用**

Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用。用户可以通过系统调用命令在自己的应用程序中调用它们。从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。

随Linux核心还提供了一些C语言函数库，这些库对系统调用进行了一些包装和扩展，因为这些库函数与系统调用的关系非常紧密，所以习惯上把这些函数也称为系统调用。

**81. 用户态到内核态的转化原理**

*用户态切换到内核态的3种方式*

* **系统调用**-这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。系统调用实质上是一个中断，而汇编指令int 就可以实现用户态向内核态切换，iret实现内核态向用户态切换 
* **异常**-当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
* **外围设备的中断**-当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**82. 源码到可执行文件的过程**

编译，编译程序读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码，再由汇编程序转换为机器语言，并且按照操作系统对可执行文件格式的要求链接生成可执行程序。

> 源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件

> Source--（编译）--> Assembly--（汇编）-->Obj--（链接）-->PE/ELF

* **编译预处理**-读取c源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理
* **编译阶段**-经过预编译得到的输出文件中，将只有常量。如数字、字符串、变量的定义，以及C语言的关键字，如main,if,else,for,while,{,},+,-,*,\，等等。预编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。
* **优化阶段**-优化处理是编译系统中一项比较艰深的技术。它涉及到的问题不仅同编译技术本身有关，而且同机器的硬件环境也有很大的关系。优化一部分是对中间代码的优化。
* **汇编过程**-汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。
* **链接程序**-由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数，等等。所有的这些问题，都需要经链接程序的处理方能得以解决。

**83. 微内核与宏内核**

* **宏内核**-简单来说，就是把很多东西都集成进内核，例如linux内核，除了最基本的进程、线程管理、内存管理外，文件系统，驱动，网络协议等等都在内核里面。优点是效率高。缺点是稳定性差，开发过程中的bug经常会导致整个系统挂掉。做驱动开发的应该经常有按电源键强行关机的经历。
* **微内核**-内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。优点是超级稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃，做驱动开发时，发现错误，只需要kill掉进程，修正后重启进程就行了，比较方便。缺点是效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了

**84. 僵尸进程**

僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源

**85. GDB调试用过吗，什么是条件断点**

GDB调试,启动程序准备调试,GDB yourpram,或者先输入GDB,然后输入 file yourpram

然后使用run或者r命令开始程序的执行,也可以使用 run parameter将参数传递给该程序

命令|命令缩写|命令说明
-|-|-
list|l|显示多行源代码
break|b|设置断点,程序运行到断点的位置会停下来
info|i|描述程序的状态
run|r|开始运行程序
display|disp|跟踪查看某个变量,每次停下来都显示它的值
step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print|p|打印内部变量值
continue|c|继续程序的运行,直到遇到下一个断点
set var name=v||设置变量的值
start|st|开始执行程序,在main函数的第一条语句前面停下来
file||装入需要调试的程序
kill|k|终止正在调试的程序
watch||监视变量值的变化
backtrace|bt|产看函数调用信息(堆栈)
frame|f|查看栈帧
quit|q|退出GDB环境

条件断点是一种拥有可设置条件属性，满足一定条件才触发的断点

*条件断点的使用*

* 测试一个变量是否满足一个给定的值。
* 让某个函数执行给定的次数。
* 只在特定的线程或处理器上才触发。

**86. 5种IO模型**

五种IO模型包括：`阻塞IO`、`非阻塞IO`、`信号驱动IO`、`IO多路转接`、`异步IO`。其中，前四个被称为同步IO。

* **阻塞IO（blocking I/O）**-
* **非阻塞IO（noblocking I/O）**-
* **信号驱动IO（signal blocking I/O）**-
* **IO多路转接（I/O multiplexing）**-
* **异步IO（asynchronous I/O）**-

**87. 异步编程的事件循环**

同步的代码进入调用栈执行完会立马弹出，异步调用的代码才会留在栈中等待执行完毕

1. setTimeout执行的时候，就是放置一个定时器，执行完这个操作之后，函数本身会立刻从栈中弹出，此时已经和这个函数无关了
2. 防止的定时器会一直留在回调队列中去，setTimeout是不会自动将回调放到事件循环队列中去，他设置了一个计时器，环境将回调放到事件循环中，一边将来某个tick将接收并执行他

**88. 操作系统为什么要分内核态和用户态**

在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。所以，CPU将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。Intel的CPU将特权级别分为4个级别：RING0,RING1,RING2,RING3。

**89. 为什么要有page cache，操作系统怎么设计的page cache**

在现代计算机系统中，CPU，RAM，DISK的速度不相同，按速度高低排列为：CPU>RAM>DISK。CPU与RAM之间、RAM与DISK之间的速度差异常常是指数级。同时，它们之间的处理容量也不相同，其差异也是指数级。为了在速度和容量上折中，在CPU与RAM之间使用CPU cache以提高访存速度，在RAM与磁盘之间，操作系统使用page cache提高系统对文件的访问速度。

**90. server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？**

State显示是LISTENING时表示处于侦听状态,就是说该端口是开放的,等待连接,但还没有被连接。

**91. 就绪状态的进程在等待什么？**

进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即运行态，就绪态，阻塞态。在五态模型中，进程分为新建态、终止态，运行态，就绪态，阻塞态。

进程就绪状态是指进程已获得除CPU之外的所有必须资源,只等待操作系统利用CPU调度算法将CPU分配给该进程以便执行. 

**92. 两个进程访问临界区资源，会不会出现都获得自旋锁的情况**

从保证临界区访问原子性的目的来考虑，自旋锁应该阻止在代码运行过程中出现的任何并发干扰。所以对同一临界区访问会出现都获得自旋锁的情况

**93. 假设临界区资源释放，如何保证只让一个线程获得临界区资源而不是都获得？**

加锁

**94. 怎么实现C++线程池**

*为什么使用线程池*-简单来说就是线程本身存在开销，我们利用多线程来进行任务处理，单线程也不能滥用，无止禁的开新线程会给系统产生大量消耗，而线程本来就是可重用的资源，不需要每次使用时都进行初始化，因此可以采用有限的线程个数处理无限的任务。

condition.h
```c++
#ifndef _CONDITION_H_
#define _CONDITION_H_

#include <pthread.h>

//封装一个互斥量和条件变量作为状态
typedef struct condition
{
    pthread_mutex_t pmutex;
    pthread_cond_t pcond;
}condition_t;

//对状态的操作函数
int condition_init(condition_t *cond);
int condition_lock(condition_t *cond);
int condition_unlock(condition_t *cond);
int condition_wait(condition_t *cond);
int condition_timedwait(condition_t *cond, const struct timespec *abstime);
int condition_signal(condition_t* cond);
int condition_broadcast(condition_t *cond);
int condition_destroy(condition_t *cond);

#endif
```

condition.c
```c++
#include "condition.h"

//初始化
int condition_init(condition_t *cond)
{
    int status;
    if((status = pthread_mutex_init(&cond->pmutex, NULL)))
        return status;
    
    if((status = pthread_cond_init(&cond->pcond, NULL)))
        return status;
    
    return 0;
}

//加锁
int condition_lock(condition_t *cond)
{
    return pthread_mutex_lock(&cond->pmutex);
}

//解锁
int condition_unlock(condition_t *cond)
{
    return pthread_mutex_unlock(&cond->pmutex);
}

//等待
int condition_wait(condition_t *cond)
{
    return pthread_cond_wait(&cond->pcond, &cond->pmutex);
}

//固定时间等待
int condition_timedwait(condition_t *cond, const struct timespec *abstime)
{
    return pthread_cond_timedwait(&cond->pcond, &cond->pmutex, abstime);
}

//唤醒一个睡眠线程
int condition_signal(condition_t* cond)
{
    return pthread_cond_signal(&cond->pcond);
}

//唤醒所有睡眠线程
int condition_broadcast(condition_t *cond)
{
    return pthread_cond_broadcast(&cond->pcond);
}

//释放
int condition_destroy(condition_t *cond)
{
    int status;
    if((status = pthread_mutex_destroy(&cond->pmutex)))
        return status;
    
    if((status = pthread_cond_destroy(&cond->pcond)))
        return status;
        
    return 0;
}
```
然后是线程池对应的threadpool.h和threadpool.c
```c++
#ifndef _THREAD_POOL_H_
#define _THREAD_POOL_H_

//线程池头文件

#include "condition.h"

//封装线程池中的对象需要执行的任务对象
typedef struct task
{
    void *(*run)(void *args);  //函数指针，需要执行的任务
    void *arg;              //参数
    struct task *next;      //任务队列中下一个任务
}task_t;


//下面是线程池结构体
typedef struct threadpool
{
    condition_t ready;    //状态量
    task_t *first;       //任务队列中第一个任务
    task_t *last;        //任务队列中最后一个任务
    int counter;         //线程池中已有线程数
    int idle;            //线程池中kongxi线程数
    int max_threads;     //线程池最大线程数
    int quit;            //是否退出标志
}threadpool_t;


//线程池初始化
void threadpool_init(threadpool_t *pool, int threads);

//往线程池中加入任务
void threadpool_add_task(threadpool_t *pool, void *(*run)(void *arg), void *arg);

//摧毁线程池
void threadpool_destroy(threadpool_t *pool);

#endif
```
```c++
#include "threadpool.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <time.h>

//创建的线程执行
void *thread_routine(void *arg)
{
    struct timespec abstime;
    int timeout;
    printf("thread %d is starting\n", (int)pthread_self());
    threadpool_t *pool = (threadpool_t *)arg;
    while(1)
    {
        timeout = 0;
        //访问线程池之前需要加锁
        condition_lock(&pool->ready);
        //空闲
        pool->idle++;
        //等待队列有任务到来 或者 收到线程池销毁通知
        while(pool->first == NULL && !pool->quit)
        {
            //否则线程阻塞等待
            printf("thread %d is waiting\n", (int)pthread_self());
            //获取从当前时间，并加上等待时间， 设置进程的超时睡眠时间
            clock_gettime(CLOCK_REALTIME, &abstime);  
            abstime.tv_sec += 2;
            int status;
            status = condition_timedwait(&pool->ready, &abstime);  //该函数会解锁，允许其他线程访问，当被唤醒时，加锁
            if(status == ETIMEDOUT)
            {
                printf("thread %d wait timed out\n", (int)pthread_self());
                timeout = 1;
                break;
            }
        }
        
        pool->idle--;
        if(pool->first != NULL)
        {
            //取出等待队列最前的任务，移除任务，并执行任务
            task_t *t = pool->first;
            pool->first = t->next;
            //由于任务执行需要消耗时间，先解锁让其他线程访问线程池
            condition_unlock(&pool->ready);
            //执行任务
            t->run(t->arg);
            //执行完任务释放内存
            free(t);
            //重新加锁
            condition_lock(&pool->ready);
        }
        
        //退出线程池
        if(pool->quit && pool->first == NULL)
        {
            pool->counter--;//当前工作的线程数-1
            //若线程池中没有线程，通知等待线程（主线程）全部任务已经完成
            if(pool->counter == 0)
            {
                condition_signal(&pool->ready);
            }
            condition_unlock(&pool->ready);
            break;
        }
        //超时，跳出销毁线程
        if(timeout == 1)
        {
            pool->counter--;//当前工作的线程数-1
            condition_unlock(&pool->ready);
            break;
        }
        
        condition_unlock(&pool->ready);
    }
    
    printf("thread %d is exiting\n", (int)pthread_self());
    return NULL;
    
}


//线程池初始化
void threadpool_init(threadpool_t *pool, int threads)
{
    
    condition_init(&pool->ready);
    pool->first = NULL;
    pool->last =NULL;
    pool->counter =0;
    pool->idle =0;
    pool->max_threads = threads;
    pool->quit =0;
    
}


//增加一个任务到线程池
void threadpool_add_task(threadpool_t *pool, void *(*run)(void *arg), void *arg)
{
    //产生一个新的任务
    task_t *newtask = (task_t *)malloc(sizeof(task_t));
    newtask->run = run;
    newtask->arg = arg;
    newtask->next=NULL;//新加的任务放在队列尾端
    
    //线程池的状态被多个线程共享，操作前需要加锁
    condition_lock(&pool->ready);
    
    if(pool->first == NULL)//第一个任务加入
    {
        pool->first = newtask;
    }        
    else    
    {
        pool->last->next = newtask;
    }
    pool->last = newtask;  //队列尾指向新加入的线程
    
    //线程池中有线程空闲，唤醒
    if(pool->idle > 0)
    {
        condition_signal(&pool->ready);
    }
    //当前线程池中线程个数没有达到设定的最大值，创建一个新的线性
    else if(pool->counter < pool->max_threads)
    {
        pthread_t tid;
        pthread_create(&tid, NULL, thread_routine, pool);
        pool->counter++;
    }
    //结束，访问
    condition_unlock(&pool->ready);
}

//线程池销毁
void threadpool_destroy(threadpool_t *pool)
{
    //如果已经调用销毁，直接返回
    if(pool->quit)
    {
    return;
    }
    //加锁
    condition_lock(&pool->ready);
    //设置销毁标记为1
    pool->quit = 1;
    //线程池中线程个数大于0
    if(pool->counter > 0)
    {
        //对于等待的线程，发送信号唤醒
        if(pool->idle > 0)
        {
            condition_broadcast(&pool->ready);
        }
        //正在执行任务的线程，等待他们结束任务
        while(pool->counter)
        {
            condition_wait(&pool->ready);
        }
    }
    condition_unlock(&pool->ready);
    condition_destroy(&pool->ready);
}
```
测试代码
```c++
#include "threadpool.h"
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

void* mytask(void *arg)
{
    printf("thread %d is working on task %d\n", (int)pthread_self(), *(int*)arg);
    sleep(1);
    free(arg);
    return NULL;
}

//测试代码
int main(void)
{
    threadpool_t pool;
    //初始化线程池，最多三个线程
    threadpool_init(&pool, 3);
    int i;
    //创建十个任务
    for(i=0; i < 10; i++)
    {
        int *arg = malloc(sizeof(int));
        *arg = i;
        threadpool_add_task(&pool, mytask, arg);
        
    }
    threadpool_destroy(&pool);
    return 0;
}
```

**95. Linux下怎么得到一个文件的100到200行**

```linux
sed -n '100,200p' inputfile
awk 'NR>=100&&NR<=200{print}' inputfile
head -200 inputfile|tail -100
```

或者

```linux
tail -n -100 xxxx.xxx | head -n 200
```

**96. awk的使用**

awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。

“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报 表，还有无数其他的功能。

```awk
awk '{pattern + action}' {filenames}
```

**97. linux内核中的Timer 定时器机制**

内核定时器是内核用来控制在未来某个时间点（基于jiffies）调度执行某个函数的一种机制，其实现位于 \<linux/timer.h\> 和 kernel/timer.c 文件中。

被调度的函数肯定是异步执行的，它类似于一种“软件中断”，而且是处于非进程的上下文中，所以调度函数必须遵守以下规则：

内核定时器的调度函数运行过一次后就不会再被运行了（相当于自动注销），但可以通过在被调度的函数中重新调度自己来周期运行。

在SMP系统中，`调度函数总是在注册它的同一CPU上运行，以尽可能获得缓存的局域性。`

* 没有 current 指针、不允许访问用户空间。因为没有进程上下文，相关代码和被中断的进程没有任何联系。
* 不能执行休眠（或可能引起休眠的函数）和调度
* 任何被访问的数据结构都应该针对并发访问进行保护，以防止竞争条件

*内核定时器的数据结构*
```c
struct timer_list {
    struct list_head entry;
    unsigned long expires;
    void (*function)(unsigned long);
    unsigned long data;
    struct tvec_base *base;
    /* ... */
};
```

其中 expires 字段表示期望定时器执行的 jiffies 值，到达该 jiffies 值时，将调用 function 函数，并传递 data 作为参数。当一个定时器被注册到内核之后，entry 字段用来连接该定时器到一个内核链表中。base 字段是内核内部实现所用的。

**98. 对进程创建时的空间进行分配算法**

* **临近适应算法(Next fit)**-从当前位置开始，搜索第一个能满足进程要求的内存空间 
* **最佳适应算法(Best fit)**-搜索整个链表，找到能满足进程要求最小内存的内存空间
* **最大适应算法(Wrost fit)**-找到当前内存中最大的空闲空间
* **首次适应算法(First fit)**-从链表的第一个开始，找到第一个能满足进程要求的内存空间

**99. 动态链接和静态链接的区别**

* **静态链接**-在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。
* **动态链接**-在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。

**100. 同步、异步、阻塞、非阻塞**

* **同步**-所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。
* **异步**-异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
* **阻塞**-阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。
* **非阻塞**-非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

**101. **

**102. **

**103. **

**104. **

**105. **

**106. **

**107. **

**108. **

**109. **

**110. **

**111. **

**112. **

**113. **

**114. **

**115. **

**116. **

**117. **

**118. **

**119. **

**120. **

**121. **

**122. **

**123. **

**124. **

**125. **

**126. **

**127. **

**128. **

**129. **

**130. **

**131. **

**132. **

**133. **

**134. **

**135. **

**136. **

**137. **

**138. **

**139. **

**140. **

**141. **

**142. **

**143. **

**144. **

**145. **

**146. **

**147. **

**148. **

**149. **
