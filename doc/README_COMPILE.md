

# 《编译原理》《Principles of Compiler Design》(龙书)笔记

主要包括词法分析、语法分析、语法制导分析、类型检查、运行环境、中间代码生成、代码生成、代码优化等

## 第一章：编译简介

编译器的编写涉及到程序设计语言，计算机体系结构、语言理论、算法和软件工程等学科。

编译器是一个程序，读入某种语言(**源语言**)编写的程序并将其翻译成一个与之等价的另一种语言(**目标语言**)编写的程序。作为这个翻译过程的一个重要部分，编译器能够将用于报告被编译的源程序中出现的错误。

不同的语言需要不同的编译器。根据编译器的构造方法或者要实现的功能，编译器被分为**一遍编译器**、**多遍编译器**、**装入并执行编译器**、**调试编译器**、**优化编译器**等多种类别。实际上，任何编译器所要完成的基本任务都是相同的。通过理解这些任务，可以利用同样的基本技术为各种各样的源语言和目标机器构建编译器。

编译器的早期工作主要集中在如何把算术表达式翻译成机器代码。

编译的组成：

* **分析**-分析部分将源程序切分成一些基本块并形成源程序的中间表示
* **综合**-综合部分把源程序的中间表示转换为所需的目标程序

在分析期间，源程序所蕴含的操作将被确定下来并被表示成一个称为**语法树**的分层结构。语法树的每个节点表示一个操作，该节点的子节点表示这个操作的参数。

首先完成某种类型分析的软件工具

* **结构编辑器**-结构编辑器将一个命令序列作为输入来构造一个源程序。如可以检查输入的格式是否正确，自动地提供关键字，自动匹配括号
* **智能打印机**-智能打印机能够对程序进行分析，打印出结构清晰的程序。
* **静态检查器**-读入一个程序并分析，不运行的情况下发现程序的潜在错误。如可以检查出源程序永远不能被执行的语句，也可以查出变量在被定义前被引用。
* **解释器**-解释器不是通过翻译来产生目标程序，而是直接执行源程序中蕴含的操作。

当然编译器不一定用于编译程序到汇编，还可以用于:

* **文本格式器**-文本格式器输入是一个字符流。输入字符流中的多数字符串是需要排版输出的字符串
* **硅编译器**-输入是一个源程序，输出是一个以适当语言书写的电路设计
* **查询解释器**-查询解释器把含有关系和布尔运算的谓词翻译成数据库命令，在数据库中查询满足该谓词的记录。

### 编译器的前驱和后继

源程序->预处理器->编译器->目标汇编程序->汇编器->可重定位机器代码->装载器->绝对机器代码

预处理器可以将存储在不同文件中的程序模块哦集成为一个完整的源程序，也能够把源程序中称为宏的缩写语句展开为原始语句加入到源程序中。

**源程序的分析过程**

* **线性分析**-从左到右地读构成源程序的字符流，而且把字符流分组为多个**记号(token)**,而记号是具有整体含义的字符序列
* **层次分析**-在层次分析中，字符串或记号在层次上划分为具有一定层次的多个嵌套组，每个嵌套组具有整体的含义
* **语义分析**-进行某些检查，以确保程序各个组成部分确实是有意义的组合在一起的。

1. 词法分析：在编译器中，线性分析被称为词法分析或者扫描。

例如，在词法分析中，一下赋值语句的字符串将被分组为以下记号token组

```
position := initial + rate * 60
```
 
* 标识符 `position`
* 赋值符号 `:=`
* 标识符 `initial` 
* 加号 `+`
* 标识符 `rate`
* 乘号 `*`
* 数字 `60`

2. 语法分析：层次分析被称为**语法分析(parsing或者syntax analysis)**,他把源程序的记号进一步分组，产生被编译器用于生成代码的语法短语。通常，源程序的语法短语用分析树来表示。比如

```
position := initial + rate * 60
```

可以被表达为如下**分析树**

```json
{
"赋值语句 := " : {
    "left" : "标识符 position", 
    "right" : {
        "表达式 + " : {
            "left" : "表达式-标识符 initial",
            "right" : {
                "表达式 * " : {
                    "left" : "表达式-标识符 rate", 
                    "right" : "表达式-数字 60"
                }
            }
        }
    }
}
}
```

程序的层次结构通常是通过**递归规则**来表达的，可能把下述规则作为**表达式定义**的一部分：

* 任何一个标识符(identifier)都是表达式
* 任何一个数(number)都是表达式
* 如果ex1和ex2都是表达式,那么ex1 + ex2; ex1 * ex2; (ex1)也是表达式

类似地，许多序言用下列规则来递归得定义**语句**:

* 如果id1是标识符，ex1是表达式,那么id1 := ex1 是一个语句
* 如果ex1是表达式，state1是一个语句，则下述代码也是语句
```
while (ex1) do state1
if (ex1) then state1
```

*注意：词法分析和语法分析的界限在某种程度上是不确定的。决定词法分析和语法分析的界限的因素是源语言是否具有递归结构，词法结构不要递归，而语法结构常常需要递归*

上下文无关法是递归规则的一种形式化，可以用来指导语法分析

例如:在识别源语言的标识符(由字母开头的字母和数字串)时，不需要递归，只需要简单扫描输入流就可以完成标识符的识别。一般地，直到遇见一个既不是字母也不是数字的字符为止，在这之前扫描到的数字和字母归结为一个**标识符记号(identifier)**,被分组的字符存储到**符号表中**

另一方面，这种线性扫描不具有分析源语言的表达式或语句的能力。

**语法树**是**分析树**的一种压缩表示

```json
{
":=" : {
    "left" : "position", 
    "right" : {
        "+" : {
            "left" : "initial",
            "right" : {
                "*" : {
                    "left" : "rate", 
                    "right" : "toreal 60"
                }
            }
        }
    }
}
}
```

3. 语义分析

语义分析阶段检测源程序的语义错误，并收集代码生成阶段要用到的类型信息。语义分析利用语法分析阶段确定的层次结构来识别表达式和语句中的操作符和操作数

语义分析的一个重要组成部分是类型检查。类型检查负责检验每个操作符的操作数是否满足源语言的说明。例如：很多程序设计语言都要求每当一个实数用于数组的索引时都要报错。程序设计语言可能允许一些操作数的强制类型转换。例如：一个二元算术操作符的操作数可以是一个整数和一个实数。这种情况下，编译器把整数强制转换成实数

4. 文本格式器中的分析

将文本格式器的输入看成是由多个盒子构成的层次结构的说明是有益的。一个盒子是一个用某种位模式填充的矩形区域，填充的位模式表明该区域被输出设备打印成浅黑像素还是黑像素

### 编译器的各阶段

编译器是分阶段执行的，除了部分编译过程，还包括**符号表管理器**和**错误处理器**

符号表是一种数据结构，每个标识符在符号表中都有一条记录，这种数据结构允许我们快速地找到每个标识符的记录

编译的每个阶段都可能遇到错误。在编译过程中遇到错误后，必须以恰当的方式进行错误处理，使编译器能继续运行，以检测出源程序中的更多错误。发现错误即停止运行的编译器不是一个好的编译器。

**语法分析**和**语义分析**阶段通常能够处理编译器所能检测到的大部分错误。词法分析阶段能够检测出输入中不能形成源语言任何记号的错误字符串。语法分析阶段可以确定记号流中违反源语言结构（语法）规则的错误。语义分析阶段试图检测出具有正确的语法结构但对操作无意义的部分。

**源程序->词法分析器->语法分析器->语义分析器->中间代码生成器->代码优化器->代码生成器**

中间代码可以看成某种抽象机的程序。源程序的中间表示应该具有两个重要性质。一是易于产生，而是易于翻译成目标程序。

比如用**三地址码**表示，类似于某种机器的汇编语言，这种机器的每个存储单元的作用类似于寄存器。三地址码由指令序列组成，每个指令最多有三个操作数。

不同编译器产生的代码的优化程度差别很大。

编译的最后一个阶段是目标代码生成，生成可重定位的机器代码或者汇编代码。这一阶段的一个关键问题是变量的寄存器分配。

### 编译器的伙伴：预处理器

预处理产生编译器的输入，一般具有以下功能

* 宏处理：预处理器允许用户在源程序中定义宏。宏是被经常使用的较长结构的缩写。
* 文件包含：预编译器可以把头文件包含到程序正文中。例如：C语言的预处理器能够用`<global.h>`文件的内容替代源程序中的语句 `#include <global.h>`
* \"理性\"预处理器：这些处理器能把现代控制流和数据结构化机制添加到比较老式的语言中。
* 语言扩充：通过大量的内部宏定义来增强语言的能力

有些编译器能够完成汇编器的工作，产生可重定位的机器代码，交给装配器(loader)或者连接编辑器(link-editor)处理。

*汇编代码*：机器代码的容易记忆的形式。汇编代码使用名称而不是二进制代码来表示操作

汇编语言也使用宏工具，汇编语言的宏工具与前面讨论过的那些宏预处理器类似。

**两遍汇编**-最简单的汇编器对输入汇编源程序文件进行两遍扫描，每遍读入文件一次。第一遍扫描中，表示存储单元的所有标识符都被识别出来并存入符号表。在第二遍扫描中，汇编器再一次从头扫描输入文件。这一次将每个操作符翻译成机器语言中代表相应操作的二进制位序列，将代表存储单元的每个标识符翻译成符号表中该标识符的地址。

第二遍扫描的输出是可重定位的机器代码。

汇编器把汇编指令翻译成的机器代码。

装配器完成程序的装入和连接编辑两项功能。

### 编译器各阶段的分组

编译的多个阶段可以分为**前端**和**后端**两个大的阶段。前端包括依赖源语言并在很大程度上独立于目标机器的某些阶段或者某些阶段的某些部分。前端一般包括词法分析、语法分析、符号表的建立、语义分析、中间代码生成以及相关的错误处理。相当一部分代码优化工作也在前端完成。

后端包括编译器中依赖于目标机器的阶段或某些阶段的某些部分。一般来说，后端完成的任务不依赖于源语言而只依赖于中间语言。后端主要包括代码优化、代码生成以及相关的错误处理和符号表的操作。

为不同的机器编写相同源语言的编译器时，通常采用如下方法：首先为所有的机器编写相同的编译器前端或者已有的编译器前端，然后为每个机器编写编译器的后端。

还可以将不同的源语言编译成同一种中间语言，对不同的前端使用相同的后端，从而得到同一机器上的不同编译器。

**编译器的遍**

编译器的若干个阶段通常是以一遍来实现的，每遍读一次输入文件、产生一个输出文件。编译器的阶段组合为遍的方式千差万别，因此我们趋向于按阶段而不是按遍来讨论编译器。

例如词法分析、语法分析、语义分析以及中间代码生成可以被组合为一遍。这样，词法分析形成的记号流可以被直接翻译成中间代码。语法分析器根据读到的记号token识别语法结构，当需要下一个记号时，通过调用词法分析器获得所需的记号。一旦语法结构找出来了，语法分析器就调用中间代码生成器完成语义分析并生成中间代码的一部分。

**减少编译的遍数**

如果编译的遍数越少，读写中间文件的时间开销就小。但是如果将多个阶段组合为一遍，就不得不将这个程序保存在内存中，但是这样消耗的空间就急剧提高。

一般词法分析器和语法分析器之间的接口通常被限制于**单个记号token**

所以在某些情况下，可以为某些尚不知晓的信息留下空白位置，待获得这些信息后再填上这些空白位置。通过**回填**技术，把中间代码和目标代码划归到一遍中。

#### 编译器的构造工具

编译器的编写者使用*调试器*、*版本管理器*、*描述器(profiler)*等软件工具是十分有益的。

当第一批编译器被编写出来不久，用于辅助编译器编写过程的系统就出现了。这些系统常被称为编译器的编译器、编译器生成器或者翻译器编写系统。

所有语言的词法分析器除了对特殊的关键字和符号识别以外基本上都是一样的。

* 分析器生成器：这类工具生成的语法分析器一般都以上下文无关文法为基础
* 扫描器生成器：这类工具一般都根据正规表达式为基础的说明自动生成词法分析器
* 语法制导翻译引擎：产生一系列的翻译程序
* 自动代码生成器：这类工具以一个规则集合为输入。
* 数据流引擎：完成高质量代码优化所需要的很多信息都包含*数据流分析*

## 第二章：简单的一遍编译器



## 第三章：词法分析

## 第四章：语法分析

## 第五章：语法制导翻译

## 第六章：类型检查

## 第七章：运行时环境

## 第八章：中间代码生成

## 第九章：代码生成

## 第十章：代码优化

# c4.c代码学习

[链接](https://github.com/Peefy/PeefyCompiler)

# Lua编译器源码学习

[链接](https://github.com/lua/lua)
