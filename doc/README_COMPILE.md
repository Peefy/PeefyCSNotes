## 编译原理

高级程序设计语言编译程序的构造原理，词法分析、语法分析、语义分析以及目标代码的生成和优化

以c语言为背景，计算机之所以能如此广泛的应用，当归功于高级程序设计语言，而编译程序的存在，使高级程序设计语言具有永恒的生命力。

**总论**

高级程序设计语言的引进，使人们能用接近于数学用语的表示法去表达算法，高级语言明显的优点为：接近于数学表示法，因而易读易理解；与具体机器无关。高级程序是符号语言，任何程序归根结底总是一个字符序列，其中包括英文字母、数字、运算符、括号以及标点符号等。计算机能直接理解的只能是二进制机器代码

从高级语言到机器可以直接接受和运行的二进制代码程序，这个翻译就是编译程序

编译原理=形式语言理论+编译技术

编译程序可以看做是程序设计语言的支持工具或环境。在编译程序的支持下，高级语言程序才可能得以运行

编译原理的内容：
* 高级程序设计语言
* 与实现编译有关的形式语言理论基本概念
* 构造编译程序的基本概念、原理和技术

编译程序构造原理又包括词法分析、语法分析、语义分析、目标代码生成与代码优化等

任何高级程序设计语言的书写总是按照一定的架构组成的。一般C程序的结构成分按概念层次由小到大可表示为：

*基本符号-符号(单词)-量-表达式-说明与语句-函数定义-程序*

程序是由一连串基本符号组成的。C语言的基本符号可以是字母、数字与界限符等。字母包括a,b,...,z,A,B,...,Z,数字包括0,1,...,9,界限符包括关键字(如char与if)和专用符号两类。专用符号可以是运算符(如+与-)、括号(如{与})、分隔符(如赋值号与语句结尾分号等)

程序设计语言的四个方面
* 语法  是指如何由程序设计语言基本符号组成程序中各个语法成分(包括程序)的一组规则，其中由符号（单词）的书写规则称为词法规则。
* 语义  是程序设计语言中按语法规则所构成的各个语法成分的意义。语义通常用非形式的口语描述
* 语用  表示语言符号及其使用者之间的关系，涉及符号的来源
* 语境  是指理解和实现程序设计语言的环境，这种环境因此包括编译环境与运行环境。语境的不同将影响到语言的实现。例如，c语言整型量通常占用2个字节，若占用4个字节，C程序的书写与运行将有很大的不同。显然，同一种程序设计语言的易移植性受语境所影响

**语法图**

<img src="https://github.com/Peefy/PeefyCSNotes/tree/master/imgs/Syntaxdiagram.png"/>

图中长方框表示语法成分，其他框表示将出现在程序中的符号。弧表示后继关系，例如，数据类型后继以函数标识符号、函数标识符号后继以圆括号，语法图中描述了四类因式，即无正负号常量、变量、用圆括号括住的表达式以及函数引用(调用)

语法图的优点是形象直观；不足是不紧凑，篇幅较大，尤其因为是非形式的，不利于语法分析程序自动生成

**BHF表示法**

BNF表示法是语法规则的形式表示系统，其中规则取如下形式。

<函数定义>::=<函数首部><函数体>
<函数定义>定义为<函数首部>后跟以<函数体>。至于<函数首部>则定义为：
<函数首部>::=<数据类型><函数标识符>(<形参表列>)
<函数首部>::=<数据类型><函数标识符>(<形参表列>|<数据类型>)<函数标识符>()

BNF表示法是描述程序设计语言的形式体系，这时引入一些新的元符号，即花括号{与},
方括号\[与\],以及圆括号(与),称扩充的BNF表示法.

当然也可以用*口语*方式定义的语法，但是往往显得不简洁，不直观

**程序执行**

高级语言程序通常可采用两种方式执行，即*解释方式*与*翻译方式*,解释执行借助于解释程序来完成。

解释方式执行程序的优点是易于查错，因为若存在错误，总可以立即从正在模拟执行的程序中确定出错语句的位置。

翻译执行借助于一个翻译程序来完成。翻译程序对整个程序进行分析，翻译成等价的机器语言(或汇编语言)程序，然后执行。所谓等价是两者的执行效果完全一致。源程序经编译程序后变成机器可执行的目标程序。

若目标程序是汇编语言程序，在运行前者首先要由汇编程序将其翻译成等价的机器语言代码。通常不明确是机器语言还是汇编语言的目标程序，统称为目标程序，也称为目标机器代码

编译方式执行源程序的优点是只需分析与翻译源程序一次，一旦获得目标程序便可以反复运行，而不必重新翻译，

但是BASIC与FOXPRO等语言，提供解释与编译两种执行方式，调试时采用解释方式，一旦排除错误，再采用编译方式

*编辑、编译、运行、调试*

**编译程序构造及有关概念**

编译程序的功能是把高级语言源程序翻译成等价的低级语言目标程序，而源程序是由基本符号序列组成，这些基本符号并不一定具有独立的含义，如字母与数字等，而且可能是由若干字符组成
如main由4个字母组成

编译程序的构造可以分为*前端*和*后端*两部分
* 前端：前端完成分析，词法分析、语法分析、语义分析
* 后端：后端完成综合，目标代码生成与代码优化
各部分的功能
> 详细介绍如下
* **词法分析** 编译程序分析工作从词法分析开始，完成词法分析工作的部分称词法分析程序，又称扫描程序 
* **语法分析** 完成语法分析的部分称语法分析程序，又称识别程序。读入由词法分析程序识别出的符号，根据给定的语法规则，识别出各个各个语法结构。在进行语法分析时，识别出语法结构的同时也就检查了语法的正确性
* **语义分析** 语义分析工作由一些语义子程序完成，这些语义子程序对语法分析树或其他内部中间表示进行静态语义检查并生成目标代码。因此内部中间表示代码是语义分析的产物，它可以是抽象语法树，但更经常生成的是逆波兰表示、三元式序列与四元式序列
* **代码优化** 是指编译时刻为改进目标代码质量而进行的各项工作。
* **目标代码生成** 目标代码可以在语义分析时生成，如果语义分析的结果是中间表示代码，就必须把中间表示代码变换成等价的目标程序，即目标语言代码

综上所述：一个编译程序由前端和后端组成，前端进行分析，完成词法分析、语法分析与语义分析，后端进行综合，完成目标代码的生成与代码优化。

前端一般是与机器无关的，而后端一般是与机器相关的。

**编译程序的分类**

* 诊断型编译程序：此类编译程序专门设计出来帮助开发与调试程序，它们仔细地检查程序，发现程序中的错误，往往能自动校正一些小错误 ，例如遗漏逗号或括号等.
* 优化型编译程序：此类编译程序专门设计出来以产生高功效的机器代码，其代价是增加编译程序复杂性与编译时间。 功效指时空功效，即期望目标程序占用的存储空间少，而运行时间短.
* 可重定目标型编译程序：通常一个编译程序是为一个特定的程序设计语言和一种特定的目标计算机而设计的，从源程序编译生成的目标程序只能在某种特定计算机上运行.
* 交叉型编译程序：通常运行由编译程序生成的目标程序的计算机应与运行编译程序的计算机具有相同的型号。
* 增量型编译程序：通常编译程序对一个源程序进行编译时发现源程序中存在错误 ，便进行修改 ，然后从头开始重新编译。

总结：高级程序设计语言程序的执行通常有解释与翻译两种方式。把高级程序设计语言程序翻译成等价的低级语言目标程序的翻译程序称编译程序。由于高级程序设计语言归根结底是字符序列或基本符号序列，编译程序实质上是一种符号处理工具。按照用途与侧重面，存在有若干种不同种类的编译程序。

**文法与语言**

当不考虑含义时，程序设计语言是一种符号语言，具有一般形式语言的共同特征。

**字母表、符号串**

字母表是有穷非空的符号集合。字母表包含了语言中所孕育出现的一切符号，当然其中至少要包含一个符号。显然，对于不同的语言可以有不同的字母表。例如二进制数语言的字母表{0,1},而对于C语言，字母表可以说是一切可打印字符组成的集合，也可以把基本符号集合看成该语言的字母表。由于字母表示符号的有穷集合，通常在字母表的集合表示中把一切符号明确写出

符号串是由字母表中的符号所组成的有穷序列，符号串x中所包含符号的个数称为符号串x的长度，用|x|表示。例如符号串abc的长度|abc|=3,而符号串010110的长度|010110|=6

子符号串，符号串的运算：联结

符号串集合：若集合A中的一切元素都是某字母表∑上的符号串，则称A为该字母表∑上的符号串集合

字母表上的符号串集合通常用大写英文字母A、B、C、...表示。例如用B表示字母表{0,1}上的符号串集合，即二进制数集合。

符号串集合的运算：交集、并集、补集，集合卡式积等。

字母表的闭包与正闭包：由于一个字母表的正闭包包含了该字母表中的符号所能组成的一切符号串，而语言是该字母表上的某个符号串集合，因此，在某个字母表上的语言是该字母表的正闭包的子集，且是真子集

**重写规则**

一个重写规则是一个有序对(U,u),通常写作U::=u,其中U是一个符号，称为重写规则的左部，而u是有穷非空符号串，称为重写规则的右部

形如U::=V(U,V都是非终结符号)的规则称为单规则。<标识符>::=<字母>

当若干个规则的左部是相同的非终结符号时，对这些规则可采用缩写的形式，
<标识符>::=<字母>|<标识符><字母>|<标识符><数字>

<字母>::=A|B|C
<数字>::=0|1|2

“|”表示“或”，<标识符>有3个选择，即<字母>、<标识符><字母>或<标识符><数字>

通常把BNF表示法称为元语言，符号“::=”与“|”等称为元语言连接符。当在规则中使用各种括号作为元语言符号时间，则沿用了扩充BNF表示法

**文法**

文法G\[Z\]是有穷非空的重写规则集合，其中Z是识别符号，而G是文法名。
定义2.13 文法G的字汇表V=VnVt,即自汇表示出现于文法规则中的一切符号所组成的集合

设G\[Z\]是一文法，如果符号串x是从识别符号Z推导所得的

**语言的形式定义**

假定G\[Z\]是一文法，由该文法描述的语言用L(G\[Z\])表示，则有如下定义.
如果一个规则形如U::=...U...,则称规则是递归的；如果规则形如U::=U...,则称左递归的；
如果形如U::=...U,则称右递归的。如果对于某文法，存在非终结符号U,对于它,U=>+ ...U...,则称该文法递归于U；如果U=>+U...,则称文法左递归于U；如果U=>+ ...U,则称该文法右递归于U.

C语言中左递归规则有：
* <标识符表>::=<标识符表>,<标识符>
右递归规则有
* <因式>::=!<因式>
C语言文法右递归于<语句>,因为有
* <语句>::=<构造语句>
* <构造语句>::=<条件语句>
* <条件语句>::=if(<布尔表达式>)<语句> else<语句>
因而，<语句>=>+ ...<语句>

还有文法递归于<表达式>,因为有:
<表达式>=>+ (<表达式>)

归结之，如果一个语言是无穷的，则描述该语言的文法必定是递归的。一般说，程序设计语言都是无穷的，因此描述它们的文法必定都是递归的

*一个文法，不论是递归定义的还是非递归定义的*，一经给定，则它所描述的语言便唯一地确定，因此一个文法的句子也称该文法所确定的语言的句子

**语言的分类**

形式语言首先于1956年由Chomsky进行描述，此后形式语言理论得到了迅速的发展

Chomsky文法G是一个四元组(Vn,VT,P,Z),其中
* VN   非终结符号集合
* VT   由终结符号
* P    有穷非空的重写规则集合
* Z    识别符号，Z∈Vn

文法G对应的语言是能从该文法G的识别符号Z产生的那些终结符号串(句子)组成的集合。
请记住，在下面的讨论中，V=Vn∪VT。

语言是句子集合，换言之，语言也是符号串集合，进而也是一般的集合。因此对语言可以进行一般的集合运算与符号串集合运算。

对于语言的运算，可以定义其并、交与补以及乘积的定义

*语言类的封闭性概念*：对于某个给定的语言类中的语言，如果进行某种运算后映像得到的新语言保持与进行运算的原有语言有相同的语言类，则称该语言对于该运算是封闭的，否则则称该语言类对该运算是不封闭的

上下文无关语言类对交运算不封闭，上下文无关语言类对补运算不封闭，正则语言类形成一个布尔代数，即正则语言类对并、补与交运算均封闭，

过程是能机械地执行的有穷指令序列；总是能终止的过程称为算法

如果能用一种算法或一个过程来识别字母表∑上的某个语言的句子，便能产生此语言。因为能系统地产生∑中的一切符号串。这种能识别或生成语言的识别器称为自动机

**3型语言与有穷状态自动机**

3型语言或正则语言所对应的自动机称为有穷状态自动机，缩写为FA. 由一个有限控制器、一个被分成若干线性单元的线性输入带及一个一次注视一个单元的读头所组成。有限控制器的各种状态组成状态集合K.

一个(确定)有穷状态自动机(D)FA是一个五元组(K,∑,M,S,F),其中：
* K是有穷非空的状态集合
* ∑是有穷非空的输入字母表
* M是从K×∑到K的映像。如果M(R,T)=Q,则表示当前状态为R且输入符号为T,将装换到状态Q;
* S是开始状态,S∈K;
* F是非空的终止状态集合,F∈K

**2型语言与下推自动机**

2型语言或上下文无关语言所对应的自动机称为下推自动机，缩写为PDA. 
也有一个有限控制器、一个线性输入带和一个读头。与有穷状态自动机的区别在于，还有一个下推存储器

下推自动机PDA是一个七元组(K,∑,τ,M,S,Z,F),其中
* K是有穷非空的状态集合；
* ∑是有穷非空的输入字母表
* τ是有穷的下推字母表
* M是从K×(∑∪{e})×τ到K×τ的有穷子集的映射
* S是开始状态.S∈K;
* Z是τ中的特殊的下推符号，称开始符号，一开始它就出现在下推存储器里;
* F是非空的终止状态集合,F∈K.

**1型语言与线性界限自动机**

1型语言或上下文有关语言所对应的自动机称为线性界限自动机，缩写为LBA。由一个有限控制器、一个输入带和一个读头组成。输入带有一个最左单元，但其右端是无穷的

线性界限自动机LBA是一个六元组(K,∑,τ,M,S,F),其中
* K是穷非空的状态集合
* τ是有穷的带符号集合
* ∑是有穷非空的输入符号集合,∑∈τ
* M是从K×τ到K×τ×{L,R}的子集的映像，这里L与R分别代表左移动与右移动
* S是开始状态,S∈K;
* F是非空的终止状态集合,F∈K

线性界限自动机与前两类与前两类自动机的区别在于，它的读头不仅能向右移动，还能向左移动以注视带上单元内的符号。另外，还能把带上单元内的原有内容改变为另一个符号。

**形式语言的分类与程序语言设计**

这里讨论形式语言理论的目的是为了把它应用于程序设计语言及其编译实现，因此必要的是从形式语言的角度来分析某种程序设计语言的相应文法属于哪一类。以C为例子，可以用BNF表示法来描述，只能认为它与上下文无关文法紧密相关。但通常自然语言是上下文有关的，不论是汉语、英语还是其他语言，这是共同的，即使程序设计语言也有类似的情况。

* (Chomsky范式)任何上下文无关语言都能由这样的文法产生，其中所有规则的形式或者是U::=VW或者是U::=T,这里U、V、W∈Vn,T∈Vt。

* (Greibach范式)任何上下文无关语言都能由这样的文法产生，其中每一个规则的形式都是U::=Tu,这里U∈Vn,T∈Vt,而u∈Vn

如果一个上下文无关文法G中存在具有下列特性的非终结符U:U=>*x∪y,其中x,y∈V+,则称U为自嵌套的非终结符号,包含自嵌套非终结符号的文法G称为自嵌套的上下文无关文法

设L是由上下文无关文法G=(Vn,Vt,P,Z)产生的语言,P中可能包含e规则,则L能由这样的文法产生，在这文法中每一个规则的形式或者是U::=u(u∈V+),或者Z::=e,且Z不出现在任何规则的右部中.

如果G是上下文无关文法,则L(G)是Vt的一个可判定子集.

文法等价变换的必要性在于:
* 使文法类与语言类一致；
* 消除文法二义性(二义性概念将在后面讨论)；
* 使文法适于应用某种分析技术 
* 使文法满足某种特殊需要

* 压缩文法等价变换
* 增广文法等价变换
* 消去单规则等价变换
* 范式文法等价变换
* 消去左递归等价变换

如果一个文法中所有规则都满足上述两个条件，则该文法不包含多余规则

如果文法G无多余规则，即每个规则U::=u都满足上述条件1和条件2，则称该文法是压缩了的

**递归左规则的消去**

* *改写规则左递归成右递归*:一个简单的例子是把规则E::=E+T|T改写成E::=T+E|T,这样左递归规则成了右递归的。消去了左递归，但并不改变所描述的语言.
* *沿用扩充BNF表示法*:规则E::=E+T|T表明E的构成为：首先是T，然后每次在其后添加“+T”.因此可将原规则改写成下列等价形式：E::=T{+T}.从而消去了左递归。事实上，一些程序设计语言的文法定义中为了避免规则左递归的存在而采用了扩充表示法

**语法分析树与句型分析**

在一些自然语言中往往利用语法分解图的图解表示来帮助理解英语句子的结构

*语法分析树的几个术语*

* **结点**:每个符号(终结符号或非终结符号)对应于一个结点，该结点就以相应符号为其名
* **边**:两结点间的连线称为边
* **根结点**:根结点是没有从上向下进入它的边，而只有从它向下射出的边的结点
* **分支**:从某结点向下射出的边连同边上的结点称为分支，分支的名字是射出该分支的结点的名字，分支的各个结点称为分支结点
* **子树**:语法树的某结点连同从它向下射出的部分(如果有的话)称该语法树的子树，该结点称为子树的根结点，例如,分别以A和B为子树根结点的子树
* **末端结点**:语法树中再没有分支从它向下射出的接待称为末端结点.

相对于(语法树)与子树,分别有(语法)树的末端结点与子树的末端结点之称

子树的末端结点符号串是相对于子树根的短语.树的末端结点符号串从左向右读时是相对于识别符号的短语，也即句型，当全是终结符号时便是句子

*二叉性*

即使是不同的推导，只要产生相同的语法树因而推导出相同的句型(句子),便认为它们是等价的.但如果对于同一个句型(句子),由于应用规则的顺序不同而产生不同的语法树,情况就截然不同

如果对于某文法的同一个句子存在有两个不同的语法树，则称该句子是二义性的。包含有二义性句子的文法称为二义性的文法;否则称该文法是无二义性的。

如果关于某语言不存在无二义性文法，则称该语言为先天二义性的

文法的二义性问题是不可判定的，即不存在一种算法能在有限步骤内确切地判定一个文法是否是二义性的

**分析技术**

* 自顶向下的分析技术:基本思想是从识别符号出发，由它推导出于输入符号串相同的终结符号串。自顶向下识别过程是一个不断建立直接推导的过程.从图形上看，自顶向下识别过程就是以识别符号作为根结点，把它作为顶，试图从它开始向着末端结点方向往下逐步建立语法树，最终目标是所得末端结点符号串正是输入符号串。

* 自底向上分析技术：从输入符号串出发，试图把它归约成识别符号。从图形上看，自底向上分析过程是以输入符号作为末端结点符号串，把它作为底，从它向着根结点方向往上构造语法树，使识别符号正是树的根结点

在一个推导中，如果每步直接推导所被替换的总是最左/右的非终结符号，则称这种推导为最左/右推导

在一个归约过程中，如果每步直接归约的总是最左/右的简单短语(句柄),则称这种归约为最左/右归约

最左(右)推导和最右(左)归约所得的结果是一样的,而且最左(右)归约中直接归纳的最左(右)简单短语,其右(左)边总是只包含终结符号

**规范推导与规范归约**

**词法分析**

**语法分析----自顶向下分析技术**

**语法分析----自底向上分析技术**

**语义分析与目标代码生成**

**运行环境**

**代码优化**

**程序错误的检查和校正**

