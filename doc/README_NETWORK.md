
# 计算机网络 TCP/IP TCP UDP HTTP

## 计算机网络

**网际互联及OSI七层模型**

* **物理层** : 定义一些电器，机械，过程和规范，如集线器(没有寻址的概念) bit
* **数据链路层** : 定义如何格式化数据，支持错误检测；以太网   frame
* **网络层** : 定义一个逻辑的寻址，选择最佳路径传输，路由数据包； packet
* **传输层** : 提供可靠和尽力而为的传输；TCP UDP 65535个端口
* **会话层** : 控制会话，建立管理终止应用程序会话；SQL ASP PHP JSP，建立及管理会话
* **表示层** : 格式化数据；ASCII JPEG MP3，数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
* **应用层** : 控制应用程序；http，ftp，dns

**五层协议**

* **物理层**-考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。
* **数据链路层**-网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
* **网络层**-为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
* **传输层**-为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务
* **应用层**-相当于OSI七层协议的**会话层**、**表示层**、**应用层**合并为**应用层**，为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

*五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。*

**TCP/IP结构**

* **网络接口层**-
* **网际层**-
* **运输层**-
* **应用层**-

**物理层的通信方式**

* **单工通信**-单向传输
* **半双工通信**-双向交替传输
* **全双工通信**-双向同时传输

**链路层的基本问题**

* **封装成帧**-将网络层传下来的分组IP数据报添加首部和尾部
* **透明传输**-在数据部分出现与尾部和首部相同的内容前面插入转义字符，如果数据部分出现转义字符，那么就在转义字符前面再添加一个转义字符。对于用户来说察觉不到转义字符的存在
* **差错检测**-目前数据链路层广泛使用了**循环冗余检验(CRC)**来检查比特差错

**信道分类**

* **广播信道**-一对多通信，会发生碰撞，通过**信道复用技术**和**CSMA/CD协议**进行协调
* **点对点信道**-一对一通信，不会发生碰撞，使用PPP协议进行控制


**信道复用技术**

* **频分复用**-频分复用的所有主机在相同的时间占用不同的频率带宽资源。
* **时分复用**-时分复用的所有主机在不同的时间占用相同的频率带宽资源。
* **统计时分复用**-是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。
* **波分复用**-光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。
* **码分复用**-为每个用户分配 m bit 的码片，并且所有的码片正交


**CSMA/CD协议**

* **多点接入**-说明这是总线型网络，许多主机以多点的方式连接到总线上。
* **载波监听**-每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
* **碰撞检测**-在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。

**局域网**

局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。

**以太网**

以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新
生成这个比特，并将其能量强度放大，目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。

**交换机**

交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。


**网络层**

因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

*与IP协议配套使用的还有三个协议*

* **地址解析协议 ARP（Address Resolution Protocol）**-网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变*每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。*
* **网际控制报文协议 ICMP（Internet Control Message Protocol）**-ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。**Ping** 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。**Traceroute** 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。
* **网际组管理协议 IGMP（Internet Group Management Protocol）**-

**IP数据报格式**

* **版本**-有 4（IPv4）和 6（IPv6）两个值
* **首部长度**-占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充
* **区分服务**-用来获得更好的服务，一般情况下不使用
* **总长度**-包括首部长度和数据部分长度
* **生存时间**-TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
* **协议**-指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。
* **首部检验和**-因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
* **标识**- 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
* **片偏移**-和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。


**IP地址**

*IP地址编址方式*

* **分类**-由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {< 网络号 >, < 主机号 >}
* **子网划分**-通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}
* **无分类**-无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

分类的IP地址由两部分组成，**网络号**和**主机号**, 

* **A类地址**-网络号8位；主机号24位
* **B类地址**-网络号16位；主机号16位
* **C类地址**-网络号24位；主机号8位
* **D类地址**-多播地址
* **E类地址**-保留为今后使用

**虚拟专用网VPN**-由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。

* **10.0.0.0 ~ 10.255.255.255**-
* **172.16.0.0 ~ 172.31.255.255**-
* **192.168.0.0 ~ 192.168.255.255**-

**路由选择协议**

* **内部网关协议 RIP**-RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。
* **内部网关协议 OSPF**-开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。最短路径优先表示使用了 Dijkstra 提出的最短路径算法SPF。
* **外部网关协议 BGP**-BGP（Border Gateway Protocol，边界网关协议

**ISP互联网服务提供商**

互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为`第一层 ISP`、`区域 ISP` 和`接入 ISP`。`互联网交换点IXP` 允许两个 ISP 直接相连而不用经过第三个 ISP。

**主机之间的通信方式**

* **客户-服务器(C/S)**-客户是服务的请求方，服务器时服务的而提供方
* **对等(P2P)**-不区分客户和服务器

**链路交换方法**

* **电路交换**-电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。
* **分组交换**-每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。

**时延**

* **排队时延**-分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量
* **处理时延**-主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。
* **传输时延**-主机或路由器传输数据帧所需要的时间。
* **传播时延**-电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。

**TCP/IP协议**

TCP/IP是因特网的通信协议，是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信

* 浏览器与服务器都在使用TCP/IP协议 
* E-mail使用TCP/IP协议
* 因特网网址是TCP/IP协议

TCP/IP 意味着 TCP 和 IP 在一起协同工作。
TCP 负责应用软件（比如您的浏览器）和网络软件之间的通信。
IP 负责计算机之间的通信。
TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。
IP 负责将包发送至接受者。

**TCP/IP定义**

TCP/IP 是供已连接因特网的计算机进行通信的通信协议。
TCP/IP 指传输控制协议/网际协议（Transmission Control Protocol / Internet Protocol）。
TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。

**TCP/IP内部**

在 TCP/IP 中包含一系列用于处理数据通信的协议：
* TCP (传输控制协议) - 应用程序之间通信
* UDP (用户数据报协议) - 应用程序之间的简单通信
* IP (网际协议) - 计算机之间的通信
* ICMP (因特网消息控制协议) - 针对错误和状态
* DHCP (动态主机配置协议) - 针对动态寻址

**TCP 使用固定的连接**

TCP用于应用程序之间的通信，会发送一个通信请求。这个请求必须被送到一个确切的地址，在双方“握手”之后，TCP将在两个应用程序之间建立一个全双工(full-duplex)的通信。
这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或被双方关闭为止。
UDP和TCP很相似，但是更简单，同时可靠性低于TCP

**IP是无连接的**

IP用于计算机之间的通信，IP是无连接的通信协议。

IP是无连接的通信协议。不会占用两个正在通信的计算机之间的通信线路。这样IP降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。

通过IP，消息(或者其他数据)被分割为小的独立的包，并通过因特网在计算机之间传送。

IP负责将每个包路由至它的目的地

**IP路由器**

当一个IP包从一台计算机被发送，会到达一个IP路由器。

IP路由器负责将这个包路由至它的目的地，直接地或者间接地通过其他的路由器。

在一个相同的通信中，一个包所经由的路径可能会和其他的包不同，而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址

**IP地址**

每个计算机必须有一个IP地址才能够连入互联网

每个IP包必须有一个地址才能够发送到另一台计算机

TCP/IP使用4组数字来为计算机编址。每个计算机必须有一个唯一的4组数字的地址.每组数字必须在0到255之间，并由点号隔开，比如:192.168.1.60

32比特=4字节，TCP/IP使用32个比特来编址。一个计算机字节是8比特。所以TCP/IP使用了4个字节

**IP V6**

IPv6是"Internet Protocol Version 6"的缩写，也被称为下一代互联网协议，是由IETF小组设计用来代替现行的IPv4协议的一种新的IP协议

在RFC1884中，规定的标准语法建议把IPv6地址的128位(16个字节)写成8个16位的无符号整数，每个整数用4个十六进制位表示，这些数之间用冒号(:)分开，例如：

```
686E：8C64：FFFF：FFFF：0：1180：96A：FFFF
```

为了保证零压缩有一个清晰的解释，建议中规定，在任一地址中，只能使用一次零压缩。该技术对已建议的分配策略特别有用，因为会有许多地址包含连续的零串

**域名**

12个阿拉伯数字很难记忆。使用一个名称更容易

用于TCP/IP地址的名字被称为域名。当键入一个域名，域名会被DNS程序翻译为数字

在全世界，数量庞大的DNS服务器被连入因特网。DNS服务器负责将域名翻译为TCP/IP地址，同时负责使用新的域名信息更新彼此的系统

当一个新的域名连同其TCP/IP地址一起注册后，全世界的DNS服务器都会对此信息进行更新

**TCP/IP 是基于 TCP 和 IP 这两个最初的协议之上的不同的通信协议的大集合。**

* **TCP-传输控制协议**
TCP用于从应用程序到网络的数据传输控制，TCP负责在数据传送之前将它们分割为IP包，然后在它们到达的时候将它们重组
* **IP-网际协议(Internet Protocol)**
IP负责计算机之间的通信，IP负责在因特网上发送和接收数据包
* **HTTP-超文本传输协议(Hyper Text Transfer Protocol)**
HTTP负责web服务器与web浏览器之间的通信。HTTP用于从web客户端(浏览器)向web服务器发送请求，并从web服务器向web客户端返回内容(网页).
* **HTTPS-安全的HTTP(HTTP Secure)**
HTTPS负责在web服务器和web浏览器之间的安全通信。
作为有代表性的应用,HTTPS会用于处理信用卡交易和其他的敏感数据
* **SSL-安全套接字层(Secure Sockets Layer)**
SSL协议用于为安全数据传输加密数据
* **SMTP-简易邮件传输协议(Simple Mail Transfer Protocol)**
SMTP用于电子邮件的传输
* **MIME-多用途因特网邮件扩展(Multi-purpose Internet Mail Extensions)**
MIME协议使SMTP有能力通过TCP/IP网络传输多媒体文件，包括声音，视频和二进制数据
* **IMAP-因特网消息访问协议(Internet Message Access Protocol)**
IMAP用于存储和取回电子邮件
* **POP-邮局协议(Post Office Protocol)**
POP用于从电子邮件服务器向个人电脑下载电子邮件
* **FTP-文件传输协议(File Transfer Protocol)**
FTP负责计算机之间的文件传输
* **NTP-网络时间协议(Network Time Protocol)**
NTP用于在计算机之间同步时间(钟)
* **DHCP-动态主机配置协议(Dynamic Host Configuration Protocol)**
DHCP用于向网络中的计算机分配动态IP地址
* **SNMP-简单网络管理协议(Simple Network Management Protocol)**
SNMP用于计算机网络的管理
* **LDAP-轻量级的目录访问协议(Lightweight Directory Access Protocol)**
LDAP用于从因特网搜集关于用户和电子邮件地址的信息
* **ICMP-因特网消息控制协议(Internet Control Message Protocol)**
ICMP负责网络中的错误处理
* **ARP-地址解析协议(Address Resolution Protocol)**
ARP- 用于通过IP来查找基于IP地址的计算机网卡的硬件地址
* **RARP-反向地址转换协议(Reverse Address Resolution Protocol)**
RARP用于通过IP查找基于硬件地址的计算机网卡的IP地址
* **BOOTP-自举协议(Boot Protocol)**
BOOTP用于从网络启动计算机
* **PPTP-点对点隧道协议(Point to Point Tunneling Protocol)**
PPTP用于私人网络之间的连接(隧道)

**HTTP协议**

HTTP协议(HyperText Transfer Protocol,超文本传输协议)是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准

HTTP是一个基于TCP/IP通信协议来传递数据(HTML文件,图片文件,查询结果)

**HTTP 工作原理**

HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求

*Web服务器有：Apache服务器，IIS服务器(Internet Information Services),Ngnix服务器*

Web服务器根据接收到的请求后，向客户端发送响应信息.HTTP默认端口号为80,但是也可以更改为8080或者其他端口

HTTP三点注意事项：

* **HTTP是无连接的**：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
* **HTTP是媒体独立的**：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的MIME-type内容类型
* **HTTP是无状态的**：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则必须重传，这样可能导致每次连接传送的数据量增大。

**HTTP消息结构**

HTTP是基于客户端/服务端(C/S)的架构模型，通过一个可靠的连接来交换信息，是一个无状态的请求/响应协议。一个HTTP“客户端”是一个应用程序(Web浏览器或其他任何客户端)，通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。

一个HTTP“服务器”同样也是一个应用程序(通常是Web服务,如Apache Web服务器或IIS服务器等)，通过接收的客户端的请求并向客户端发送HTTP响应数据.

HTTP使用统一资源表示符(Uniform Resource Identifiers, URI)来传输数据和建立连接.一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展(MIME)[RFC2045]来传送

**客户端请求消息**

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：*请求行(request line)*、*请求头部(header)*、*空行*和*请求数据*四个部分组成

**服务器相应消息**

HTTP相应也由四个部分组成，分别是：*状态行*, *消息报头*, *空行*, *相应正文*
```xml
HTTP/1.1 200 OK
Date: Sat, 31, Dec 2005 23:59:59 GMT
Content-Type: text/html;charset=ISO-8859-1
Content-Length: 122

<html>
<head>
<title>Homepage</title>
</head>
<body>
contents
<!-- comments -->
</body>
</html>

```

**使用HTTP GET来向服务器获取数据**

客户端请求

```http
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
```

服务器相应

```http
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
```

**HTTP协议的8种请求类型**

HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下：

* `OPTIONS`: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用Web服务器发送'*'的请求来测试服务器的功能性
* `HAED`: 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息
* `GET`: 向特定的资源发出请求
* `POST`: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改
* `PUT`: 向指定资源位置上传其最新内容
* `DELETE`: 请求服务器删除 Request-URI 所标识的资源
* `TRACE`: 回显服务器收到的请求，主要用于测试或诊断
* `CONNECT`: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器

虽然HTTP的请求方式有8种，但是我们在实际应用中常用的也就是**get**和**post**,其他请求方式也都可以通过两种方式间接的来实现

**HTTP请求方法**

根据HTTP标准，HTTP请求可以使用多种请求方法。

HTTP1.0定义了三种请求方法：`GET` `POST` 和 `HEAD` 方法

序号|方法|描述
-|-|-
1|GET|请求指定的页面信息，并放回实体主体
2|HEAD|类似于get请求,只不过返回响应中没有具体的内容，用于获取报头
3|POST|向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
4|PUT|从客户端向服务器传送的数据取代指定的文档的内容。
5|DELETE|请求服务器删除指定的页面。
6|CONNECT|HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
7|OPTIONS|允许客户端查看服务器的性能。
8|TRACE|回显服务器收到的请求，主要用于测试或诊断。

**HTTP响应头信息**

HTTP请求头提供了关于请求，响应或者其他的发送实体的信息

应答头|说明
-|-
Allow|服务器支持哪些请求方法(如GET/POST等)
Content-Encoding|文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面
Content-Length|表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果想要利用持久连接的优势，可以把输入文档写入ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头
Date|当前的GMT时间
Expires|应该在什么时候认为文档已经过期，从而不再缓存它
Last-Modified|文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态
Location|表示客户应当到哪里去提取文档。Location通常不是直接设置的
Refresh|表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，还可以通过指令让浏览器读取指定的页面。*注意：Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态码则可以阻止*
Server|服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置
Set-Cookie|设置和页面关联的Cookie。
WWW-Authenticate|客户应该在Authorization头中提供什么类型的授权信息.在包含401(Unauthorized)状态行的应答中这个头是必需的。*注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问*

**HTTP状态码**

当浏览器访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头(server header)用以相应浏览器的请求

HTTP状态码的英文为HTTP Status Code

常见HTTP状态码

* **200**：请求成功 
* **301**：资源(网页等)被永久转移到其他URL
* **404**：请求的资源(网页等)不存在
* **500**：内部服务器错误

**HTTP状态码分类**

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码分为5种类型

分类|描述
-|-
1**|信息，服务器收到请求，需要请求者继续执行操作
2**|成功，操作被成功接收并处理
3**|重定向，需要进一步的操作以完成请求
4**|客户端错误，请求包含语法错误或无法完成请求
5**|服务器错误，服务器在处理请求的过程中发生了错误

**HTTP状态码列表**

状态码|状态码英文名称|中文描述
-|-|-
**100**|Continue|继续。客户端应继续其请求
**101**|Switching Protocols|切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
**200**|OK|请求成功。一般用于GET与POST请求
**201**|Created|已创建。成功请求并创建了新的资源
**202**|Accepted|已接受。已经接受请求，但未处理完成
**203**|Non-Authoritative Information|非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
**204**|No Content|无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
**205**|Reset Content|重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
**206**|Partial Content|部分内容。服务器成功处理了部分GET请求
**300**|Multiple Choices|多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
**301**|Moved Permanently|永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
**302**|Found|临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
**303**|See Other|查看其它地址。与301类似。使用GET和POST请求查看
**304**|Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
**305**|Use Proxy|使用代理。所请求的资源必须通过代理访问
**306**|Unused|已经被废弃的HTTP状态码
**307**|Temporary Redirect|临时重定向。与302类似。使用GET请求重定向
**400**|Bad Request|客户端请求的语法错误，服务器无法理解
**401**|Unauthorized|请求要求用户的身份认证
**402**|Payment Required|保留，将来使用
**403**|Forbidden|服务器理解请求客户端的请求，但是拒绝执行此请求
**404**|Not Found|服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
**405**|Method Not Allowed|客户端请求中的方法被禁止
**406**|Not Acceptable|服务器无法根据客户端请求的内容特性完成请求
**407**|Proxy Authentication Required|请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
**408**|Request Time-out|服务器等待客户端发送的请求时间过长，超时
**409**|Conflict|服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突
**410**|Gone|客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
**411**|Length Required|服务器无法处理客户端发送的不带Content-Length的请求信息
**412**|Precondition Failed|客户端请求信息的先决条件错误
**413**|Request Entity Too Large|由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
**414**|Request-URI Too Large|请求的URI过长（URI通常为网址），服务器无法处理
**415**|Unsupported Media Type|服务器无法处理请求附带的媒体格式
**416**|Requested range not satisfiable|客户端请求的范围无效
**417**|Expectation Failed|服务器无法满足Expect的请求头信息
**500**|Internal Server Error|服务器内部错误，无法完成请求
**501**|Not Implemented|服务器不支持请求的功能，无法完成请求
**502**|Bad Gateway|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
**503**|Service Unavailable|由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
**504**|Gateway Time-out|充当网关或代理的服务器，未及时从远端服务器获取请求
**505**|HTTP Version not supported|服务器不支持请求的HTTP协议的版本，无法完成处理

**HTTP Content-Type**

Content-Type,内容类型，一般是指网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些Asp网页点击的结果却是下载到的一个文件或一张图片的原因

[Content-Type对照表](http://www.runoob.com/http/http-content-type.html)

## TCP、UDP、HTTP的异同

* 1.TCP/IP是一个协议组，可以分为三个层次：网络层、传输层和应用层；在网络层有IP协议，ICMP协议、ARP协议、RARP协议和BOOTP协议；在传输层有TCP协议和UDP协议；在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议

* 2.HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息

* 3.HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应 消息，因此减少了链接建立的次数和经常性的链接开销。

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！

-|TCP|UDP
-|-|-
是否连接|面向连接|面向非连接
传输可靠性|可靠|不可靠
应用场合|传输大量的数据，对可靠性要求较高的场合|传送少量数据、对可靠性要求不高的场景
速度|慢|快

## 计算机网络问答

### 网络概述

**1. TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？**

OSI的7层从上到下分别是 7 应用层(TELNET，HTTP，FTP，NFS，SMTP) 6 表示层 5 会话层 4 传输层 （TCP，UDP）3 网络层 （IP)）2 数据链路层 1 物理层

### 运输层

**2. 讲一下TCP的连接和释放连接。**

**TCP建立连接（三次握手，即进行了两次确认）：**

* Client向Server发送连接请求
* Server接收到Client的请求后，同意建立连接后向Client发送ACK确认报文，并为这次连接的建立分配资源
* Client接收到对方发来的ACK确认后也向Server发送ACK确认报文，连接建立完成

**TCP拆除连接（四次挥手）：**

数据传输完成后，Client和Server都处于ESTABLISHED状态，通信的双方都可以进行释放连接的动作。
* Client主动发送释放连接的请求，并停止发送数据。Client将连接释放报文段的首部的FIN置为1，其序号为u，它等于前面已传送过的数据的最后一个字节的序号加1。此时Client进入FIN-WAIT-1（终止等待1）状态。
* Server接收到Client的释放请求后发出确认，确认号是u+1，而确认报文段自己的序号是v，等于Server前面已经传送过的数据的最后一个字节的序号加1。接着Server进入CLOSE-WAIT（关闭等待）状态，并且TCP会通知高层应用程序，此时Client到Server的连接已经关闭，但Server到Client的连接仍然存在，因此此时的TCP连接处于半关闭状态。Server仍然有可能会给Client发送数据，Client也要接收。
* Client收到来自对方的确认后，进入FIN-WAIT-2（终止等待2）状态，等待Server释放连接。
* Server发送完数据后发送释放报文段，其应用程序就通知TCP释放连接。Server发送的报文段中必须将FIN置为1。由于在半关闭状态Server可能也发送了数据，因此假定此时Server的序号为w，除此之外，Server也必须重复上次发送的确认号u+1。发送完后Server进入LAST-ACK（最后确认）状态，等待Client确认。
* Client收到释放报文段后发送确认报文段。此时Client并没有释放掉连接，而是进入TIME-WAIT（时间等待）状态，等过了2MSL时间后才进入到CLOSED状态。

**3. TCP有哪些应用场景**

tcp协议是面向连接的，可靠的数据传输协议，但是它的传输数据速率相比于udp协议比较慢。它适用于对数据传输可靠性要求比较高的场景，例如文本传输之类的。TCP协议需要三次握手通信成功后进行建立。

应用场景：互联网和企业网上客户端应用，数据传输性能让位于数据传输的完整性，可控制性和可靠性。

**4. tcp为什么可靠**

TCP和UDP协议的区别在于TCP可以提供可靠的网络数据传输，但UDP不能。

ACK机制：由于通信过程的不可靠性，传输的数据不可避免的会出现丢失、延迟、错误、重复等各种状况，TCP协议为解决这些问题设计了一系列机制。
这个机制的核心，就是发送方向接收方发送数据后，接收方要向发送方发送ACK（回执）。如果发送方没接收到正确的ACK，就会重新发送数据直到接收到ACK为止。
比如：发送方发送的数据序号是seq，那么接收方会发送seq + 1作为ACK，这样发送方就知道接下来要发送序号为seq + 1的数据给接收方了。

* **数据丢失或延迟**-发送方发送数据seq时会起一个定时器，如果在指定时间内没有接收到ACK seq + 1，就把数据seq再发一次。
* **数据乱序**-接收方上一个收到的正确数据是seq + 4，它返回seq + 5作为ACK。这时候它收到了seq + 7，因为顺序错了，所以接收方会再次返回seq + 5给发送方。
* **数据错误**-每一个TCP数据都会带着数据的校验和。接收方收到数据seq + 3以后会先对校验和进行验证。如果结果不对，则发送ACK seq + 3，让发送方重新发送数据。
* **数据重复**-接收方直接丢弃重复的数据即可。

TCP还做了很多对传输过程的优化，比如滑动窗口机制，比如慢启动机制。

**5. tcp为什么要建立连接**

建立可靠性连接，主机A向主机B发送连接请求会发送一个包，主机B接收到主机A的请求同意连接会向主机A返回一个包，主机A确认无误后会再次发送给主机B确认

**6. 阐述TCP的4次挥手**

数据传输完成后，Client和Server都处于ESTABLISHED状态，通信的双方都可以进行释放连接的动作。
* Client主动发送释放连接的请求，并停止发送数据。Client将连接释放报文段的首部的FIN置为1，其序号为u，它等于前面已传送过的数据的最后一个字节的序号加1。此时Client进入FIN-WAIT-1（终止等待1）状态。
* Server接收到Client的释放请求后发出确认，确认号是u+1，而确认报文段自己的序号是v，等于Server前面已经传送过的数据的最后一个字节的序号加1。接着Server进入CLOSE-WAIT（关闭等待）状态，并且TCP会通知高层应用程序，此时Client到Server的连接已经关闭，但Server到Client的连接仍然存在，因此此时的TCP连接处于半关闭状态。Server仍然有可能会给Client发送数据，Client也要接收。
* Client收到来自对方的确认后，进入FIN-WAIT-2（终止等待2）状态，等待Server释放连接。
* Server发送完数据后发送释放报文段，其应用程序就通知TCP释放连接。Server发送的报文段中必须将FIN置为1。由于在半关闭状态Server可能也发送了数据，因此假定此时Server的序号为w，除此之外，Server也必须重复上次发送的确认号u+1。发送完后Server进入LAST-ACK（最后确认）状态，等待Client确认。
* Client收到释放报文段后发送确认报文段。此时Client并没有释放掉连接，而是进入TIME-WAIT（时间等待）状态，等过了2MSL时间后才进入到CLOSED状态。

**7. 讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。**

* **输入网址**-输入访问网站地址：俗称url
* **缓存解析**-浏览器获取url后，之后去解析，先去缓存当中看看有没有，从浏览器缓存-系统缓存-路由器缓存当中查看，如果有从缓存当中显示页面。缓存就是把之前访问的web资源，如js，css，图片保存在本机的内存或者磁盘当中
* **域名解析**-DNS解析：域名到IP地址的转换。域名的解析工作由DNS服务器完成，解析后可以获取域名相应的IP地址
* **tcp连接，三次握手**-域名解析之后，浏览器向服务器发起http请求，tcp连接，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。1.客户端向服务器发送连接请求报文；2.服务器接受客户端发送的连接请求后回复ACK报文，并为这次连接分配资源；3.客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源
* **服务器收到请求**-服务器收到浏览器发送的请求信息，返回一个响应头和一个响应体。
* **页面渲染**-浏览器收到服务器发送的响应头和响应体，进行客户端渲染，生成Dom树、解析css样式、js交互

**8. http和https的区别**

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**9. http的请求有哪些，应答码502和504有什么区别**

* **OPTIONS**：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
* **HEAD**：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。
* **GET**：向特定的资源发出请求。
* **POST**：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。
* **PUT**：向指定资源位置上传其最新内容。
* **DELETE**：请求服务器删除 Request-URI 所标识的资源。
* **TRACE**：回显服务器收到的请求，主要用于测试或诊断。
* **CONNECT**：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。

502表示错误网关，无效网关 。 504表示网关超时，说明服务器作为网关或代理，但是没有及时从上游服务器收到请求。

**10. http1.1和1.0的区别**

* HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理。HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。HTTP 1.1则支持持久连接Persistent Connection, 并且默认使用persistent  connection. 在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行. 更加多的请求头和响应头(比如HTTP1.0没有host的字段).
* HTTP 1.1增加host字段。在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。
* 100(Continue) Status(节约带宽)。HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。
* HTTP/1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
* HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。

**11. 说说ssl四次握手的过程**

* 客户端请求建立SSL链接，并向服务端发送一个随机数（client random）和客户端支持的加密方法（比如RSA），此时是明文传输的。
* 服务端选择客户端支持的一种加密算法并生成另一个随机数（server random），并将授信的服务端证书和公钥下发给客户端。
* 客户端收到服务端的回复，会校验服务端证书的合法性，若合法，则生成一个新的随机数premaster secret并通过服务端下发的公钥及加密方法进行加密，然后发送给服务端
* 服务端收到客户端的回复，利用已知的加解密方式进行解密，同时利用client random、server random和premater secret通过一定算法生成对称加密key - session key。

此后，数据传输即通过对称加密方式进行加密传输。
从以上过程可以看看https实际上是用了对称加密技术和非对称加密技术，非对称加密解密速度慢，但安全性高，用来加密对称加密的密钥；而对称加密虽然安全性低，但解密速度快，可以用于传输数据的加密。

**12. 304状态码有什么含义？**

304状态码是告诉浏览器可以从缓存中获取所请求的资源。
当浏览器请求某一文件时，发现自己缓存的文件有Last-Modified，就会在httpRequest里面添加消息头If-Modified-Since 和If-Non-Match，服务器在收到reqeust时，和服务器本地文件对比，如果没有更新，则仅仅返回一个响应头Head（状态码304，而没有响应体），客户端在收到这个响应时，就会从本地缓存加载请求的资源。

### 网络层

**13. arp协议，arp攻击**

ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。

ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。ARP攻击主要是存在于局域网网络中，局域网中若有一台计算机感染ARP木马，则感染该ARP木马的系统将会试图通过“ARP欺骗”手段截获所在网络内其它计算机的通信信息，并因此造成网内其它计算机的通信故障。

**14. icmp协议**

ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

**15. 讲一下路由器和交换机的区别？**

* **外形上**-交换机通常端口比较多，路由器端口少体积小，（路由器一般都集成了交换机的功能，LAN口就是作为交换机的端口来使，WAN用于连接外网的端口。
* **工作层次不同**-交换机在数据链路层（实现数据帧的转发），而路由器在网络层（肩负着网络互连的作用）。
* **数据的转发对象不同**-交换机是根据MAC地址转发数据帧，而路由器是根据IP地址来转发数据报。IP地址决定最终数据要到达某一台主机，而MAC地址是决定下一跳将要交给哪一台设备（一般是交换机或者路由器），IP地址是软件实现的，可以描述主机所在的网络，MAC地址是硬件实现的，每一个网卡在出厂时都会将全世界唯一的MAC地址固化在ROM中，因此MAC不可改，IP可改
* **分工不同**-交换机主要是用于组建局域网，而路由器则负责让主机连接外网，多台主机可以通过网线连接到交换机，这时候就组建好了局域网，就可以通过网线连接到交换机，这时就组建好了局域网，就可以将数据发给局域网中的其他主机，然而通过交换机组建的局域网是不能访问外网的，这时就需要路由器为我们来打开外网大门，局域网的所有主机使用的都是私网的IP,所以必须通过，路由器转换为公网IP之后才能访问外网
* **冲突域和广播域**-交换机分割冲突域，但不分割广播域，而路由器分割广播域。由交换机连接的网段，仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，这时会导致广播风暴和安全漏洞。而连接在路由器上的网段会被分配到不同的广播域。路由器不会转发广播数据。交换机会转发广播数据给局域网中的所有主机，值得说明的是单播的数据包在局域网中会被交换机唯一的送到目标主机，其他主机不会接受到数据，这是区别于原始的集线器的。

### 应用层

**16. DNS寻址过程**

* 客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器
* 先发送给本地dns服务器，本地的就会在自己的区域里面查找，若找到，根据此记录进行解析，若没有找到，就会在本地的缓存里面查找
* 本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器
* 根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址
* 客户机的dns服务器根据返回的信息接着访问下一级的dns服务器
* 这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息
* 客户机的本地的dns服务器会将查询结果返回给我们的客户机
* 客户机根据得到的ip信息访问目标主机，完成解析过程

**17. 负载均衡反向代理模式优点及缺点**

通代理方式是代理内部网络用户访问internet上服务器的连接请求，客户端必须指定代理服务器,并将本来要直接发送到internet上服务器的连接请求发送给代理服务器处理。

反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。

反向代理负载均衡技术是把将来自internet上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。

反向代理负载均衡能以软件方式来实现，如apache mod_proxy、netscape proxy等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT负载均衡技术也有此优点）。

**18. 确保节点传输存储的可靠性**

传输层的功能是保证数据可靠地从发送结点发送到目标结
点.例如,传输层确保数据以相同的顺序发送和接收,并且传输后接收结点会给出响应.当
在网络中采用虚拟电路时,传输层还要负责跟踪指定给每一电路的唯一标识值.这一I D称为
端口,连接标识或套接字,是由会话层指定的.传输层还要确定包错误校验的级别,最高的
级别可以确保包在可以接受的时间内无差错地从结点发送到结点.
用于在传输层间通信的协议采用了多种可靠性措施.0类是最简单的协议,不执行错误校
验或流控制,依靠网络层来执行这些功能.1类协议监控包传输错误,如果检查到了错误,就
通报发送结点的传输层让它重新发送包.2类协议监控传输层和会话层间的传输错误并提供流
控制.流控制确保设备不会以高于网络或接收设备接收信息的速度来发送信息.3类协议除提
供1类和2类协议的功能外,还可以在某些环境下恢复丢失的包.最后,4类协议除执行3类协
议的功能外,还具有扩展的错误监控和恢复能力.

**19. TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程**

TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接

TCP协议保证数据传输可靠性的方式主要有：校验和；序列号；确认应答；超时重传；连接管理；流量控制；拥塞控制

**TCP建立连接（三次握手，即进行了两次确认）：**

* Client向Server发送连接请求
* Server接收到Client的请求后，同意建立连接后向Client发送ACK确认报文，并为这次连接的建立分配资源
* Client接收到对方发来的ACK确认后也向Server发送ACK确认报文，连接建立完成

**TCP拆除连接（四次挥手）：**

数据传输完成后，Client和Server都处于ESTABLISHED状态，通信的双方都可以进行释放连接的动作。
* Client主动发送释放连接的请求，并停止发送数据。Client将连接释放报文段的首部的FIN置为1，其序号为u，它等于前面已传送过的数据的最后一个字节的序号加1。此时Client进入FIN-WAIT-1（终止等待1）状态。
* Server接收到Client的释放请求后发出确认，确认号是u+1，而确认报文段自己的序号是v，等于Server前面已经传送过的数据的最后一个字节的序号加1。接着Server进入CLOSE-WAIT（关闭等待）状态，并且TCP会通知高层应用程序，此时Client到Server的连接已经关闭，但Server到Client的连接仍然存在，因此此时的TCP连接处于半关闭状态。Server仍然有可能会给Client发送数据，Client也要接收。
* Client收到来自对方的确认后，进入FIN-WAIT-2（终止等待2）状态，等待Server释放连接。
* Server发送完数据后发送释放报文段，其应用程序就通知TCP释放连接。Server发送的报文段中必须将FIN置为1。由于在半关闭状态Server可能也发送了数据，因此假定此时Server的序号为w，除此之外，Server也必须重复上次发送的确认号u+1。发送完后Server进入LAST-ACK（最后确认）状态，等待Client确认。
* Client收到释放报文段后发送确认报文段。此时Client并没有释放掉连接，而是进入TIME-WAIT（时间等待）状态，等过了2MSL时间后才进入到CLOSED状态。

**20. TCP的模型，状态迁移**

TCP提供一种面向连接的，可靠的字节流服务。面对连接意味着两个使用TCP的应用，在彼此交换数据之前必须先建立一个连接

**21. HTTP和HTTPS的区别，以及HTTPS有什么缺点？**

*区别*

* https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
* http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
* http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
* http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全

*HTTPS的优点*

* 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
* HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
* HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本
* 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”

*HTTPS的缺点*

* HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电
* HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电
* SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用
* SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗
* HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行

**22. HTTP返回码**

HTTP状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到 RFC 2518、RFC 2817、RFC 2295、RFC 2774 与 RFC 4918 等规范扩展。所有状态码的第一个数字代表了响应的五种状态之一。所示的消息短语是典型的，但是可以提供任何可读取的替代方案。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。

* 1xx 消息
* 2xx 成功
* 3xx 重定向
* 4xx 请求错误
* 5xx 服务器错误

**23. IP地址作用，以及MAC地址作用**

IP地址是指Internet协议使用的地址，而MAC地址是Ethernet协议使用的地址.IP地址与MAC地址之间并没有什么必然的联系，MAC地址是Ethernet NIC（网卡）上带的地址，为48位长。每个Ethernet NIC厂家必须向IEEE组织申请一组MAC地址，在生产NIC时编程于NIC卡上的串行EEPROM中。

MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。

**24. 操作系统中的中断**

操作系统与外部设备之间：主要通过中断机制来实现。

例如，在键盘在输出的时候，首先会把数据写到一个特定的缓冲区，这个缓冲区是有大小限制，如果数据超过其限制大小，先前数入的内容就会被冲掉，所以外部设备会通过中断机制，向内核发出指令，然后内核通过调用设备驱动程序，及时把缓冲区的内容读写到内核中。这样就达成了一个操作系统内核与外部设备进行数据交互的过程。

**25. OSI七层模型和TCP/IP四层模型，每层列举2个协议**

**网际互联及OSI七层模型**

* **物理层** : 定义一些电器，机械，过程和规范，如集线器(没有寻址的概念) bit
* **数据链路层** : 定义如何格式化数据，支持错误检测；以太网   frame
* **网络层** : 定义一个逻辑的寻址，选择最佳路径传输，路由数据包； packet
* **传输层** : 提供可靠和尽力而为的传输；TCP UDP 65535个端口
* **会话层** : 控制会话，建立管理终止应用程序会话；SQL ASP PHP JSP
* **表示层** : 格式化数据；ASCII JPEG MP3
* **应用层** : 控制应用程序；http，ftp

**26. 请你说一说TCP的三次握手和四次挥手的过程及原因**

*三次握手*

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入`SYN_SENT`状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即`SYN+ACK`包，此时服务器进入`SYN_RECV`状态；

第三次握手：客户端收到服务器的`SYN+ACK`包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入`ESTABLISHED`（TCP连接成功）状态，完成三次握手。

*四次挥手*

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。

6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

*为什么连接的时候是三次握手，关闭的时候却是四次握手？*

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

**27. 搜索baidu，会用到计算机网络中的什么层？每层是干什么的**

OSI模型的七层应该都会涉及

当输入www.baidu.com时，计算机会请求DNS服务器，进行域名转换，得到服务器IP地址，同时对服务器发出请求，服务器响应请求，返回百度网页。在百度搜索上输入HTML5进行搜索时，这是表单请求提交的过程，可以用普通表单实现也可以用JavaScript和ajax，其作用是将HTML5的做为参数传递到后台，然后进行数据库查询，同时后端servlet服务返回页面请求的结果。

**28. 请你说一说TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？**

拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。 
首先需要了解一个概念，为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。 

拥塞控制主要是四个算法： 
* 慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。
* 拥塞避免：**当拥塞窗口cwnd达到一个阈值时，如16**，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。
* 进入慢启动过程：在收到3个duplicate ACK时就开启重传，而不用等到RTO超时  
* 快速恢复：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。 

**29. 请问TCP用了哪些措施保证其可靠性**

* **连接管理**：TCP是面向连接的，三次握手和四次挥手都是为了保证本次数据传送的可靠性
* **序号**：保证数据段的按序到达
* **确认应答机制**：TCP中对发送的每一个字节都进行了编号，也就是序列号，接收端收到一个数据段后，便会对该数据段进行确认，并回应一个ACK报文，
* **超时重传机制**：主机A发送给主机B数据报后一段时间内如果没有收到主机B对应的确认报文，就认为这一个或者这几个数据报都丢失了，即触发重传机制，重新发送没有被确认的报文，
* **流量控制**：根据接收端处理数据的能力来控制发送端发送数据的速度。
* **拥塞控制**：引入“慢启动”机制，开始先发送少量数据，探清当前网络状态，再决定以多大的速度发送数据。从连续收到三个重复的确认转入拥塞避免

**30. TCP/IP数据链路层的交互过程**

数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思

数据链路层的功能：定义了电信号的分组方式，head包含：(固定18个字节) ；发送者／源地址，6个字节；接收者／目标地址，6个字节；数据类型，6个字节；data包含：(最短46字节，最长1500字节) 

**31. 传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文**

以传输层采用TCP或者UPD、网络层采用IP、链路层采用Ethernet为例，可以看到TCP/IP中报文的封装过程如图所示。用户数据经过应用层协议封装后传递给传输层，传输层封装TCP头部，交给网络层，网络层封装IP头部后，再交给数据链路层，数据链路层封装Ethernet帧头和帧尾，交给物理层，物理层以比特流的形式将数据发送到物理线路上。

协议字段（报头检验和前面那个），其值为6，则为TCP，其值为17，则为UDP。

**32. 基于做过socket的开发？具体网络层的操作该怎么做？**

建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。

**33. 请问server端监听端口，但还没有客户端连接进来，此时进程处于什么状态？**

State显示是LISTENING时表示处于侦听状态,就是说该端口是开放的,等待连接,但还没有被连接。

**34. 请问TCP三次握手是怎样的？**

第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

**35. 请问tcp握手为什么两次不可以？为什么不用四次？**

第一次握手：客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里

第二次握手：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。

第三次握手：客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1

**36. 请你来说一下TCP拥塞控制？**

拥塞控制是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载，是一个全局性的过程。TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。 

**拥塞控制**：引入“慢启动”机制，开始先发送少量数据，探清当前网络状态，再决定以多大的速度发送数据。从连续收到三个重复的确认转入拥塞避免

拥塞控制主要是四个算法： 
* 慢启动：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。
* 拥塞避免：**当拥塞窗口cwnd达到一个阈值时，如16**，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。
* 进入慢启动过程：在收到3个duplicate ACK时就开启重传，而不用等到RTO超时  
* 快速恢复：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。 

**37. TCP和UDP的区别和各自适用的场景**

*区别*

* 基于连接与无连接；
* 对系统资源的要求（TCP较多，UDP少）；
* UDP程序结构较简单；
* 流模式与数据报模式；
* TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。

**38. TCP time_wait状态**

time_wait状态是四次挥手中server向client发送FIN终止连接后进入的状态。

time_wait存在的原因有两点：
* 可靠的终止TCP连接
* 保证让迟来的TCP报文段有足够的时间被识别并丢弃

time_wait状态是一般有client的状态。并且会占用port，有时产生在server端，由于server主动断开连接或者发生异常。

**39. http协议**

HTTP协议(HyperText Transfer Protocol,超文本传输协议)是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准

HTTP是一个基于TCP/IP通信协议来传递数据(HTML文件,图片文件,查询结果)

**40. GET和POST的区别**

GET和POST是HTTP请求的两种基本方法，最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

* GET在浏览器回退时是无害的，而POST会再次提交请求
* GET产生的URL地址可以被Bookmark，而POST不可以
* GET请求会被浏览器主动cache，而POST不会，除非手动设置
* GET请求只能进行url编码，而POST支持多种编码方式
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留
* GET请求在URL中传送的参数是有长度限制的，而POST么有
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
* GET参数通过URL传递，POST放在Request body中

**41. socket编程中服务器端和客户端主要用到哪些函数**

服务器程序：

* 1.创建一个socket，用函数socket()
* 2.绑定IP地址、端口等信息到socket上，用函数bind()
* 3.设置允许的最大连接数，用函数listen()
* 4.接收客户端上来的连接，用函数accept()
* 5.收发数据，用函数send()和recv()，或者read()和write()
* 6.关闭网络连接

```c++
#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<string.h>
#include<pthread.h>
#define PORT 8000 
void *ClientHandler(void *arg)
{
	pthread_detach(pthread_self())  ;  //线程分离 
	int ret;
	int fd=*(int *)arg;
	char buf[32]={0};
	
	ret=recv(fd,buf,sizeof(buf),0);   //4个参数 
	if(-1==ret)
	{
		perror("recv");
	//	exit(1);
	}
	printf("recv from %d client %s!\n",fd,buf);
	memset(buf,0,sizeof(buf));
}
 
int main()
{
	int sockfd;
	struct sockaddr_in server_addr;
	struct sockaddr_in client_addr;	
	int fd[1000]={0},i=0;
	pthread_t tid; 
	sockfd=socket(PF_INET,SOCK_STREAM,0);    //创建socket ，有 3个参数
	if(-1==sockfd)     //若创建失败 
	{
	 	perror("socket");
	 	exit(1);
	} 
	  int length=sizeof(server_addr);
	  server_addr.sin_family=PF_INET;  //PF_INET 地址族
	  server_addr.sin_port= PORT;   //端口号
	  server_addr.sin_addr.s_addr=inet_addr("127.0.0.1");   //ip地址  绑定什么连接什么地址 
	  int ret=bind(sockfd,(struct sockaddr *)&server_addr,length);    //绑定   ,强制类型转换 
	  if(-1==ret)
	  {
	  	perror("bind");
	  	exit(1);
	  }
	  ret=listen(sockfd,5);  //监听队列的大小
	  if(-1==ret)    //若监听失败 
	  {
	  	perror("listen");
	  	exit(1);
	   } 
	   while(1)  
	   {
	   		length=sizeof(client_addr);
	   		memset (&client_addr,0,sizeof(client_addr));
	   		fd[i]=accept(sockfd,(struct sockaddr *)&client_addr,&length);
	   		if(-1==ret)
	   		{
	   			perror("accept");
	   			exit(1);
		    }
		    printf("accept port %d fd %d\n",client_addr.sin_port,fd[i]);
		    ret=pthread_create(&tid,NULL,ClientHandler,&fd[i]) ;              //创建线程
			if(ret!=0)
			{
				perror("pthread_create");
			} 
			i++; 
		//	pthread_join();  //等待线程结束，回收资源 ,阻塞性函数，聊天室不能用。 卡死
		     
	   }
	return 0;
}
```

客户端程序：

* 1.创建一个socket，用函数socket()
* 2.设置要连接的对方的IP地址和端口等属性
* 3.连接服务器，用函数connect()
* 4.收发数据，用函数send()和recv()，或者     read()和write()
* 5.关闭网络连接 

```c++
#include<stdio.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<stdlib.h>
#include<string.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<pthread.h>

#define PORT 8000

int main()
{
	int sockfd,ret;
	char buf[32]={0};
	struct sockaddr_in server_addr;
	sockfd=socket(PF_INET,SOCK_STREAM,0); 
	if(sockfd==-1)
	{
		perror("socket");
		exit(1);
	}	
    int length=sizeof(server_addr);
	server_addr.sin_family=PF_INET;  //PF_INET 地址族
	server_addr.sin_port= PORT;   //端口号
	server_addr.sin_addr.s_addr=inet_addr("127.0.0.1");   //ip地址  绑定什么连接什么地址 
	ret=connect (sockfd,(struct sockaddr *)&server_addr,length);
	if(-1==ret)
	{
		perror("connect");
		exit(1);
	}
	while(1)
	{
		scanf("%s",buf);
		ret=send(sockfd,buf,strlen(buf),0);
		if(-1==ret)
		{
			perror("send");
		}
		memset(buf,0,sizeof(buf));
	}
	return 0;
}
```

**42. 数字证书是什么，里面都包含那些内容**

数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份

包含的内容:

* 证书的版本信息；
* 证书的序列号，每个证书都有一个唯一的证书序列号；
* 证书所使用的签名算法；
* 证书的发行机构名称，命名规则一般采用X.500格式；
* 证书的有效期，通用的证书一般采用UTC时间格式，它的计时范围为1950-2049；
* 证书所有人的名称，命名规则一般采用X.500格式；
* 证书所有人的公开密钥；
* 证书发行者对证书的签名。

**43. C++ UDP的connect函数**

udp客户端建立了socket后可以直接调用sendto()函数向服务器发送数据，但是需要在sendto()函数的参数中指定目的地址/端口，但是可以调用connect()函数先指明目的地址/端口，然后就可以使用send()函数向目的地址发送数据了，因为此时套接字已经包含目的地址/端口，也就是send()函数已经知道包含目的地址/端口。

**44. 阻塞，非阻塞，同步，异步**

同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。

* **阻塞**-线程在执行中如果遇到（I/O 操作）如磁盘读写或网络通信，通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为 阻塞。
* **非阻塞**-非阻塞是这样定义的，当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个事件。
* **同步**-同步的代码意味着每一次执行一个操作，在一个操作完成之前，代码的执行会被阻塞，无法移到下一个操作上。也就是说代码的执行会在函数返回前停止。直到函数返回后，代码才会继续执行。
* **异步**-异步就意味着函数的执行无需等待某个操作的结果就可以继续执行，其操作的结果会在事件发生时由回调来处理。

**45. Socket编程的send() recv() accept() socket()函数？**

* **send()**-send（）是一个计算机函数，功能是向一个已经连接的socket发送数据，如果无错误，返回值为所发送数据的总数，否则返回SOCKET_ERROR。
* **recv()**-recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；
* **accept()**-accept()是在一个套接口接受的一个连接。accept（）是c语言中网络编程的重要的函数，本函数从s的等待连接队列中抽取第一个连接，创建一个与s同类的新的套接口并返回句柄。
* **socket()**-socket()函数用于根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所用的资源。如果协议protocol未指定（等于0），则使用缺省的连接方式。

**46. http协议会话结束标志怎么截出来？**

会话关闭，有2种方式。一种是用户主动清除会话信息，另一种是会话超时。会话超时不是守护任务（或自动任务）周期性检查处理的，而是访问会话信息时，根据会话信息中的“上一次更新时间”到现在的时间差，与会话周期比较，超出周期的，清除会话信息，即会话关闭。

**47. TCP/IP数据链路层的交互过程**

数据链路层的协议定义了通过通信媒介互连的设备之间传输的规范。通信媒介包括双绞线电缆、同轴电缆、光纤、电波以及红外线等介质。此外,各个设备之间有时也会通过交换机、网桥、中继器等中转数据。

数据链路层处理的数据也不是单纯的0、1序列,该层把他们集合为一个叫做帧的块,然后再进行传输。

*MAC地址*

用于识别数据链路中互连的节点,地址长48比特,一般用16进制数表示。在使用网卡的情况下,MAC地址会被烧入到ROM中。因此,任何一个网卡的MAC地址都是唯一的。

**48. QUIC协议**

QUIC是Quick UDP Internet Connection的简称，是Google制定的一种基于UDP的低时延的互联网传输层协议。TCP/IP协议簇是互联网的基础。其中传输层协议包括TCP和UDP协议。与TCP协议相比，UDP更为轻量，但是错误校验也要少得多。这意味着UDP往往效率更高，但是可靠性比不上TCP。通常游戏、流媒体以及VoIP等应用均采用UDP，而网页、邮件、远程登录等大部分的应用均采用TCP。

QUIC能把两种协议的优势结合起来，同时实现低时延和高可靠并将其应用到更高安全的协议上，于是就有了QUIC。

以往典型的安全TCP连接(TCP+TLS)往往需要在发送与接收端先进行2，3轮的握手通信才能正式开始数据传输。而利用QUIC协议，如果双方此前通信过的话马上就可以对话(即便双方此前未通信过时延也只有100毫秒，是TCP+TLS用时的1/3)。此外，QUIC还增加了拥塞控制和自动重传等功能，所以可靠性上要比UDP高。

从目标来看，QUIC跟SPDY(HTTP/2基础)很多方面是类似的，但是后者仍然基于TCP，所以仍然会存在部分相同的时延问题。

为什么不直接改进TCP，TCP往往直接内置到操作系统内核中，所以改良UDP。

**49. **

**50. **

**51. **

**52. **

**53. **

**54. **

**55. **

**56. **

**57. **

**58. **

**59. **

**60. **

**61. **

**62. **

**63. **

**64. **

**65. **

**66. **

**67. **

**68. **

**69. **

**70. **

**71. **

**72. **

**73. **

**74. **

**75. **

**76. **

**77. **

**78. **

**79. **

**80. **

**81. **

**82. **

**83. **

**84. **

**85. **

**86. **

**87. **

**88. **

**89. **

**90. **

**91. **

**92. **

**93. **

**94. **

**95. **

**96. **

**97. **

**98. **

**99. **

**100. **

**101. **

**102. **

**103. **

**104. **

**105. **

**106. **

**107. **

**108. **

**109. **

**110. **

**111. **

**112. **

**113. **

**114. **

**115. **

**116. **

**117. **

**118. **

**119. **

**120. **

**121. **

**122. **

**123. **

**124. **

**125. **

**126. **

**127. **

**128. **

**129. **

**130. **

**131. **

**132. **

**133. **

**134. **

**135. **

**136. **

**137. **

**138. **

**139. **

**140. **

**141. **

**142. **

**143. **

**144. **

**145. **

**146. **

**147. **

**148. **

**149. **

**150. **

**151. **

**152. **

**153. **

**154. **

**155. **

**156. **

**157. **

**158. **

**159. **

**160. **

**161. **

**162. **

**163. **

**164. **

**165. **

**166. **

**167. **

**168. **

**169. **

**170. **

**171. **

**172. **

**173. **

**174. **

**175. **

**176. **

**177. **

**178. **

**179. **

**180. **

**181. **

**182. **

**183. **

**184. **

**185. **

**186. **

**187. **

**188. **

**189. **

**190. **

**191. **

**192. **

**193. **

**194. **

**195. **

**196. **

**197. **

**198. **

**199. **




